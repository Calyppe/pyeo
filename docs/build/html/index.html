
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Welcome to Pyeo’s documentation! &#8212; Pyeo  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="welcome-to-pyeo-s-documentation">
<h1>Welcome to Pyeo’s documentation!<a class="headerlink" href="#welcome-to-pyeo-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>
<div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>Python For Earth Observation is a collection of functions for downloading, manipulating, combining and classifying
geospatial raster and vector data. It is intended to require a minimum of dependencies - most functions only require
the basic GDAL/OGR/OSR stack and Numpy.</p>
</div>
<div class="section" id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h1>
<p>With Git and Miniconda or Anaconda installed, <code class="code docutils literal notranslate"><span class="pre">cd</span></code> to an install location then run the following lines</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git clone https://github.com/clcr/pyeo.git
<span class="nb">cd</span> pyeo
conda env create --file environment.yml --name pyeo_env
conda activate pyeo_env
python -m pip install . -vv
</pre></div>
</div>
<p>In a Python prompt, try  <code class="code docutils literal notranslate"><span class="pre">import</span> <span class="pre">pyeo</span></code> - you should see no errors.</p>
</div>
<div class="section" id="quick-start">
<h1>Quick start<a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Before you start, you will need:</p>
</div></blockquote>
<p>-A linux (or maybe mac, untested) machine
-A raster of your window area
-A shapefile of polygons over your training areas with a field containing class labels
-A raster to classify. This can be the same as your original raster.
All rasters and shapefiles should be in the same projection; ideally in the local projection of your satellite data.
-Git
-Anaconda/Miniconda</p>
<p>INSTALLATION</p>
<p>git clone <a class="reference external" href="https://github.com/clcr/pyeo">https://github.com/clcr/pyeo</a>
cd pyeo
git checkout restructure      # This gets you the present working branch
conda env create –file environment.yml –name pyeo_env
echo export PYEO=$(pwd) &gt;&gt; ~/.bashrc    #Or just append to the end of your .bashrc
echo export PATH=$PATH:$PYEO/bin
chmod 755 bin/*</p>
<p>USE</p>
<p>conda activate pyeo_env
cd (whereever your data is)
extract_signatures your_raster.tif your_shapefile.shp output.csv
# You can now explore your signatures as a .csv file, and perform any interim processing
create_model_from_signatures output.csv model.pkl
classify_image your_raster model.pkl output_image.tif</p>
</div>
<div class="section" id="assumptions-and-design-decisions">
<h1>Assumptions and design decisions<a class="headerlink" href="#assumptions-and-design-decisions" title="Permalink to this headline">¶</a></h1>
<p>###Rasters ###</p>
<ul class="simple">
<li><p>Can read from any gdal-readable format</p></li>
<li><p>Stores internally as geotiff</p></li>
<li><p>Named with the .tif suffix</p></li>
<li><p>Most raster processing is done using numpy and getVirtualMemArray</p></li>
<li><p>Unless otherwise stated, <strong>all rastesrs are assumed to be in a projected coordinate system</strong> - i.e. in meters.
Functions may fail if passed a raster in lat-long projection</p></li>
</ul>
<p>### Masks ###</p>
<ul class="simple">
<li><p>Some Pyeo functions include options for applying masks</p></li>
<li><p>A raster may have an associated mask</p></li>
<li><dl class="simple">
<dt>A mask is a geotif with an identical name as the raster it’s masking with a .msk extension</dt><dd><ul>
<li><p>For example, the mask for my_sat_image.tif is my_sat_image.msk</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A mask is</dt><dd><ul>
<li><p>a single band raster</p></li>
<li><p>of identical height, width and resolution of the related image</p></li>
<li><p>contains values 0 or 1</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A mask is applied by multiplying it with each band of its raster</dt><dd><ul>
<li><p>So any pixel with a 0 in its mask will be removed, and a 1 will be kept</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>### Timestamps ###</p>
<ul class="simple">
<li><dl class="simple">
<dt>Pyeo uses the same timestamp convention as ESA: yyyymmddThhmmss</dt><dd><ul>
<li><p>For example, 1PM on 27th December 2020 would be 20201227T130000</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>All timestamps are in UTC</p></li>
</ul>
<p>### Models ###
- All models are serialised and deserialised using joblib.dump or joblib.load</p>
</div>
<div class="section" id="module-pyeo.classification">
<span id="function-reference"></span><h1>Function reference<a class="headerlink" href="#module-pyeo.classification" title="Permalink to this headline">¶</a></h1>
<div class="section" id="pyeo-classification">
<h2>pyeo.classification<a class="headerlink" href="#pyeo-classification" title="Permalink to this headline">¶</a></h2>
<p>Contains every function to do with map classification. This includes model creation, map classification and processes
for array manipulation into scikit-learn compatible forms.</p>
<dl class="function">
<dt id="pyeo.classification.autochunk">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">autochunk</code><span class="sig-paren">(</span><em class="sig-param">dataset</em>, <em class="sig-param">mem_limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.autochunk" title="Permalink to this definition">¶</a></dt>
<dd><p>EXPERIMENTAL Calculates the number of chunks to break a dataset into without a memory error. Presumes that 80% of the
memory on the host machine is available for use by Pyeo.
We want to break the dataset into as few chunks as possible without going over mem_limit.
mem_limit defaults to total amount of RAM available on machine if not specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> – The dataset to chunk</p></li>
<li><p><strong>mem_limit</strong> – The maximum amount of memory available to the process. Will be automatically populated from os.sysconf if missing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>The number of chunks to most efficiently break the image into.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.change_from_composite">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">change_from_composite</code><span class="sig-paren">(</span><em class="sig-param">image_path</em>, <em class="sig-param">composite_path</em>, <em class="sig-param">model_path</em>, <em class="sig-param">class_out_path</em>, <em class="sig-param">prob_out_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.change_from_composite" title="Permalink to this definition">¶</a></dt>
<dd><p>Stacks an image with a composite and classifies each pixel change with a scikit-learn model
The image that is classified is has the following bands</p>
<blockquote>
<div><p>composite blue
composite green
composite red
composite IR
image blue
image green
image red
image IR</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_path</strong> – The path to the image</p></li>
<li><p><strong>composite_path</strong> – The path to the composite</p></li>
<li><p><strong>model_path</strong> – The path to a .pkl of a scikit-learn classifier that takes 8 features</p></li>
<li><p><strong>class_out_path</strong> – A location to save the resulting classification .tif</p></li>
<li><p><strong>prob_out_path</strong> – A location to save the probability raster of each pixel</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.classify_directory">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">classify_directory</code><span class="sig-paren">(</span><em class="sig-param">in_dir</em>, <em class="sig-param">model_path</em>, <em class="sig-param">class_out_dir</em>, <em class="sig-param">prob_out_dir</em>, <em class="sig-param">apply_mask=False</em>, <em class="sig-param">out_type='GTiff'</em>, <em class="sig-param">num_chunks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.classify_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Classifies every file ending in .tif in in_dir using model at model_path. Outputs are saved
in class_out_dir and prob_out_dir, named [input_name]_class and _prob, respectively.</p>
<p>See the documentation for classification.classify_image() for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_dir</strong> – The path to the directory containing the rasters to be classified.</p></li>
<li><p><strong>model_path</strong> – The path to the .pkl file containing the model.</p></li>
<li><p><strong>class_out_dir</strong> – The directory that will store the classified maps</p></li>
<li><p><strong>prob_out_dir</strong> – The directory that will store the probability maps of the classified maps</p></li>
<li><p><strong>apply_mask</strong> – If present, uses the corresponding .msk files to mask the directories</p></li>
<li><p><strong>out_type</strong> – The raster format of the class image. Defaults to GTiff (geotif)</p></li>
<li><p><strong>num_chunks</strong> – The number of chunks to break an image into.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.classify_image">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">classify_image</code><span class="sig-paren">(</span><em class="sig-param">image_path</em>, <em class="sig-param">model_path</em>, <em class="sig-param">class_out_path</em>, <em class="sig-param">prob_out_path=None</em>, <em class="sig-param">apply_mask=False</em>, <em class="sig-param">out_type='GTiff'</em>, <em class="sig-param">num_chunks=10</em>, <em class="sig-param">nodata=0</em>, <em class="sig-param">skip_existing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.classify_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a class map from a raster and a model.
This applies the model’s fit() function to each pixel in the input raster, and saves the result into an output
raster. The model is presumed to be a scikit-learn fitted model created using one of the other functions in this
library (create_model_from_rasters, create_model_from_signatures).</p>
<p>To fit into a</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_path</strong> – The path to the raster image to be classified.</p></li>
<li><p><strong>model_path</strong> – The path to the .pkl file containing the model</p></li>
<li><p><strong>class_out_path</strong> – The path that the classified map will be saved at.</p></li>
<li><p><strong>prob_out_path</strong> – If present, the path that the class probability map will be stored at.</p></li>
<li><p><strong>apply_mask</strong> – If True, uses the .msk file corresponding to the image at image_path to skip any invalid pixels.</p></li>
<li><p><strong>out_type</strong> – The raster format of the class image. Defaults to GTiff (geotif)</p></li>
<li><p><strong>num_chunks</strong> – The number of chunks the image is broken into prior to classification. The smaller this number, the faster
classification will run - but the more likely you are to get a outofmemory error.</p></li>
<li><p><strong>nodata</strong> – The value to write to masked pixels</p></li>
<li><p><strong>skip_existing</strong> – If true, do not run if class_out_path already exists</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>If you want to create a custom model, the object is presumed to have the following methods and attributes:</dt><dd><ul class="simple">
<li><p><a href="#id3"><span class="problematic" id="id4">model.n_classes_</span></a> : the number of classes the model will produce</p></li>
<li><p>model.n_cores : The number of CPU cores used to run the model</p></li>
<li><p>model.predict() : A function that will take a set of band inputs from a pixel and produce a class.</p></li>
<li><dl class="simple">
<dt>model.predict_proba()<span class="classifier">If called with prob_out_path, a function that takes a set of n band inputs from a pixel</span></dt><dd><p>and produces <a href="#id5"><span class="problematic" id="id6">n_classes_</span></a> outputs corresponding to the probabilties of a given pixel being
that class</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.create_model_for_region">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">create_model_for_region</code><span class="sig-paren">(</span><em class="sig-param">path_to_region</em>, <em class="sig-param">model_out</em>, <em class="sig-param">scores_out</em>, <em class="sig-param">attribute='CODE'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.create_model_for_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes all .tif files in a given folder and creates a pickled scikit-learn model for classifying them.
Wraps classification.create_trained_model() ; see docs for that for the details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path_to_region</strong> – Path to the folder containing the tifs.</p></li>
<li><p><strong>model_out</strong> – Path to location to save the .pkl file</p></li>
<li><p><strong>scores_out</strong> – Path to save the cross-validation scores</p></li>
<li><p><strong>attribute</strong> – The label of the field in the training shapefiles that contains the classification labels.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.create_model_from_signatures">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">create_model_from_signatures</code><span class="sig-paren">(</span><em class="sig-param">sig_csv_path</em>, <em class="sig-param">model_out</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.create_model_from_signatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a .csv file containing class signatures - produced by extract_features_to_csv - and uses it to train
and pickle a scikit-learn model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sig_csv_path</strong> – The path to the signatures file</p></li>
<li><p><strong>model_out</strong> – The location to save the pickled model to.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>At present, the model is an ExtraTreesClassifier arrived at by tpot:
model = ens.ExtraTreesClassifier(bootstrap=False, criterion=”gini”, max_features=0.55, min_samples_leaf=2,</p>
<blockquote>
<div><p>min_samples_split=16, n_estimators=100, n_jobs=4, class_weight=’balanced’)</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.create_trained_model">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">create_trained_model</code><span class="sig-paren">(</span><em class="sig-param">training_image_file_paths</em>, <em class="sig-param">cross_val_repeats=5</em>, <em class="sig-param">attribute='CODE'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.create_trained_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a trained model from a set of training images with associated shapefiles.</p>
<p>This assumes that each image in training_image_file_paths has in the same directory a folder of the same
name containing a shapefile of the same name. For example, in the folder training_data:</p>
<p>training_data
—area1.tif
—area1</p>
<blockquote>
<div><p>—area1.shp
—area1.dbx
…rest of shapefile for area 1 …</p>
</div></blockquote>
<p>—area2.tif
—area2</p>
<blockquote>
<div><p>—area2.shp
—area2.dbx
…rest of shapefile for area 2…</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>training_image_file_paths</strong> – A list of filepaths to training images.</p></li>
<li><p><strong>cross_val_repeats</strong> – The number of cross-validation repeats to use</p></li>
<li><p><strong>attribute</strong> – The label of the field in the training shapefiles that contains the classification labels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>model</em> – A fitted scikit-learn model. See notes.</p></li>
<li><p><em>scores</em> – The cross-validation scores for model</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For full details of how to create an appropriate shapefile, see [here](../index.html#training_data).
At present, the model is an ExtraTreesClassifier arrived at by tpot:
model = ens.ExtraTreesClassifier(bootstrap=False, criterion=”gini”, max_features=0.55, min_samples_leaf=2,</p>
<blockquote>
<div><p>min_samples_split=16, n_estimators=100, n_jobs=4, class_weight=’balanced’)</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.extract_features_to_csv">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">extract_features_to_csv</code><span class="sig-paren">(</span><em class="sig-param">in_ras_path</em>, <em class="sig-param">training_shape_path</em>, <em class="sig-param">out_path</em>, <em class="sig-param">attribute='CODE'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.extract_features_to_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a raster and a shapefile containing training polygons, extracts all pixels into a CSV file for further
analysis.</p>
<dl class="simple">
<dt>This produces a CSV file where each row corresponds to a pixel. The columns are as follows:</dt><dd><p>Column 1: Class labels from the shapefile field labelled as ‘attribute’.
Column 2… : Band values from the raster at in_ras_path.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_ras_path</strong> – The path to the raster used for creating the training dataset</p></li>
<li><p><strong>training_shape_path</strong> – The path to the shapefile containing classification polygons</p></li>
<li><p><strong>out_path</strong> – The path for the new .csv file</p></li>
<li><p><strong>attribute</strong> – The label of the field in the training shapefile that contains the classification labels.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.get_training_data">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">get_training_data</code><span class="sig-paren">(</span><em class="sig-param">image_path</em>, <em class="sig-param">shape_path</em>, <em class="sig-param">attribute='CODE'</em>, <em class="sig-param">shape_projection_id=4326</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.get_training_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an image and a shapefile with categories, returns training data and features suitable
for fitting a scikit-learn classifier.</p>
<p>This extracts every pixel in image_path touched by the polygons in shape_path</p>
<p>For full details of how to create an appropriate shapefile, see [here](../index.html#training_data).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_path</strong> – The path to the raster image to extract signatures from</p></li>
<li><p><strong>shape_path</strong> – The path to the shapefile containing labelled class polygons</p></li>
<li><p><strong>attribute</strong> – The field containing the class labels</p></li>
<li><p><strong>shape_projection_id</strong> – The projection of the shapefile</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>training_data</em> – A numpy array of shape (n_pixels, bands), where n_pixels is the number of pixels covered by the training polygons</p></li>
<li><p><em>features</em> – A 1-d numpy array of length (n_pixels) containing the class labels for the corresponding pixel in training_data</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For performance, this uses scikit’s sparse.nonzero() function to get the location of each training data pixel.
This means that this will ignore any classes with a label of ‘0’.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.raster_reclass_binary">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">raster_reclass_binary</code><span class="sig-paren">(</span><em class="sig-param">img_path</em>, <em class="sig-param">rcl_value</em>, <em class="sig-param">outFn</em>, <em class="sig-param">outFmt='GTiff'</em>, <em class="sig-param">write_out=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.raster_reclass_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a raster and reclassifies rcl_value to 1, with all others becoming 0. In-place operation if write_out is True.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img_path</strong> – Path to 1 band input  raster.</p></li>
<li><p><strong>rcl_value</strong> – Integer indication the value that should be reclassified to 1. All other values will be 0.</p></li>
<li><p><strong>outFn</strong> – Output file name.</p></li>
<li><p><strong>outFmt</strong> – Output format. Set to GTiff by default. Other GDAL options available.</p></li>
<li><p><strong>write_out</strong> – Boolean. Set to True by default. Will write raster to disk. If False, only an array is returned</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Reclassifies numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.reshape_ml_out_to_raster">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">reshape_ml_out_to_raster</code><span class="sig-paren">(</span><em class="sig-param">classes</em>, <em class="sig-param">width</em>, <em class="sig-param">height</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.reshape_ml_out_to_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the output of a pixel classifier and reshapes to a single band image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>classes</strong> – A 1-d numpy array of classes from a pixel classifier</p></li>
<li><p><strong>width</strong> – The width in pixels of the image the produced the classification</p></li>
<li><p><strong>height</strong> – The height in pixels of the image that produced the classification</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A 2-dimensional Numpy array of shape(width, height)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.reshape_prob_out_to_raster">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">reshape_prob_out_to_raster</code><span class="sig-paren">(</span><em class="sig-param">probs</em>, <em class="sig-param">width</em>, <em class="sig-param">height</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.reshape_prob_out_to_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the probability output of a pixel classifier and reshapes it to a raster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probs</strong> – A numpy array of shape(n_pixels, n_classes)</p></li>
<li><p><strong>width</strong> – The width in pixels of the image that produced the probability classification</p></li>
<li><p><strong>height</strong> – The height in pixels of the image that produced the probability classification</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.classification.reshape_raster_for_ml">
<code class="sig-prename descclassname">pyeo.classification.</code><code class="sig-name descname">reshape_raster_for_ml</code><span class="sig-paren">(</span><em class="sig-param">image_array</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.classification.reshape_raster_for_ml" title="Permalink to this definition">¶</a></dt>
<dd><p>A low-level function that reshapes an array from gdal order [band, y, x] to scikit features order [x*y, band]</p>
<p>For classification, scikit-learn functions take a 2-dimensional array of features of the shape (samples, features).
For pixel classification, features correspond to bands and samples correspond to specific pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>image_array</strong> – A 3-dimensional Numpy array of shape (bands, y, x)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A 2-dimensional Numpy array of shape (samples, features)</p>
</dd>
</dl>
</dd></dl>

</div>
<span class="target" id="module-pyeo.array_utilities"></span><p>Contains routines for manipulating arrays.</p>
<dl class="function">
<dt id="pyeo.array_utilities.project_array">
<code class="sig-prename descclassname">pyeo.array_utilities.</code><code class="sig-name descname">project_array</code><span class="sig-paren">(</span><em class="sig-param">array_in</em>, <em class="sig-param">depth</em>, <em class="sig-param">axis</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.array_utilities.project_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new array with an extra dimension. Data is projected along that dimension to depth.</p>
</dd></dl>

<span class="target" id="module-pyeo.coordinate_manipulation"></span><div class="section" id="pyeo-coordinate-manipulation">
<h2>pyeo.coordinate_manipulation<a class="headerlink" href="#pyeo-coordinate-manipulation" title="Permalink to this headline">¶</a></h2>
<p>Contains a set of functions for transforming spatial coorinates between projections and pixel indicies.</p>
<p>Unless otherwise stated, all functions assume that any geometry, rasters and shapefiles are using the same projection.
If they are not, there may be unexpected errors.</p>
<p>Some of these functions call for an AOI shapefile. This is a single-layer shapefile containing only the geometry
of one polygon.</p>
<p>These functions all work on the objects provided by the ogr and gdal libraries. If you wish to use them in your own
processing, a gdal.Image object is usually the output from gdal.Open() and an ogr.Geometry object can be obtained from
a well-known text (wkt) string using the  snipped <a href="#id1"><span class="problematic" id="id2">`</span></a>object=ogr.ImportFromWkt(“mywkt”). For more information on wkt, see
<a class="reference external" href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry">https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry</a> and the “QuickWKT” QGIS plugin.</p>
<dl class="function">
<dt id="pyeo.coordinate_manipulation.align_bounds_to_whole_number">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">align_bounds_to_whole_number</code><span class="sig-paren">(</span><em class="sig-param">bounding_box</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.align_bounds_to_whole_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new bounding box with it’s height and width rounded to the nearest whole number.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bounding_box</strong> – An ogr.Geometry object containing a raster’s bounding box as a polygon.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>An ogr.Geometry object containing the aligned bounding box.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.check_overlap">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">check_overlap</code><span class="sig-paren">(</span><em class="sig-param">raster</em>, <em class="sig-param">aoi</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.check_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>A test to see if a raster and an AOI overlap.
:param raster: A gdal.Image object
:param aoi: A ogr.Dataset object containing a single polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>True if the raster and the polygon overlap, oherwise False.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.floor_to_resolution">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">floor_to_resolution</code><span class="sig-paren">(</span><em class="sig-param">input</em>, <em class="sig-param">resolution</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.floor_to_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns input rounded DOWN to the nearest multiple of resolution. Used to prevent float errors on pixel boarders.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> – The value to be rounded</p></li>
<li><p><strong>resolution</strong> – The resolution</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>The largest value between input and 0 that is divisible by resolution.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses the following formula: input-(input%resolution)</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.get_aoi_bounds">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">get_aoi_bounds</code><span class="sig-paren">(</span><em class="sig-param">aoi</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.get_aoi_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a wkbPolygon geometry with the bounding rectangle of a single-polygon shapefile</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>aoi</strong> – An ogr.Dataset object containing a single layer.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.get_aoi_intersection">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">get_aoi_intersection</code><span class="sig-paren">(</span><em class="sig-param">raster</em>, <em class="sig-param">aoi</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.get_aoi_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a wkbPolygon geometry with the intersection of a raster and a shpefile containing an area of interest</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raster</strong> – A raster containing image data</p></li>
<li><p><strong>aoi</strong> – A shapefile with a single layer and feature</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a ogr.Geometry object containing a single polygon with the area of intersection</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.get_aoi_size">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">get_aoi_size</code><span class="sig-paren">(</span><em class="sig-param">aoi</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.get_aoi_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the width and height of the bounding box of an aoi.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>aoi</strong> – A shapefile containing a single layer with a single polygon</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A tuple of (width, height)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.get_combined_polygon">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">get_combined_polygon</code><span class="sig-paren">(</span><em class="sig-param">rasters</em>, <em class="sig-param">geometry_mode='intersect'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.get_combined_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a polygon containing the combined boundary of each raster in rasters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rasters</strong> – A list of raster objects opened with gdal.Open()</p></li>
<li><p><strong>geometry_mode</strong> – If ‘intersect’, returns the boundary of the area that all rasters cover.
If ‘union’, returns the boundary of the area that any raster covers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ogr.Geometry() containing a polygon.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.get_local_top_left">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">get_local_top_left</code><span class="sig-paren">(</span><em class="sig-param">raster1</em>, <em class="sig-param">raster2</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.get_local_top_left" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the top-left corner of raster1 in the array of raster 2.
Assumes both rasters are in the same projection and units.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raster1</strong> – The raster to get the top-left corner of.</p></li>
<li><p><strong>raster2</strong> – The raster that raster1’s top-left corner is over.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A tuple of (x_pixel, y_pixel), containing the indicies of the point in the raster.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.get_poly_bounding_rect">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">get_poly_bounding_rect</code><span class="sig-paren">(</span><em class="sig-param">poly</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.get_poly_bounding_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a polygon of the bounding rectangle of an input polygon.
:param poly: An ogr.Geometry object containing a polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>An ogr.Geometry object with a four-point polygon representing the bounding rectangle.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.get_poly_intersection">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">get_poly_intersection</code><span class="sig-paren">(</span><em class="sig-param">poly1</em>, <em class="sig-param">poly2</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.get_poly_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>A functional wrapper for ogr.Geometry.Intersection()</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.get_poly_size">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">get_poly_size</code><span class="sig-paren">(</span><em class="sig-param">poly</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.get_poly_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the width and height of a bounding box of a polygon</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>poly</strong> – A ogr.Geometry object containing the polygon.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A tuple of (width, height)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.get_raster_bounds">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">get_raster_bounds</code><span class="sig-paren">(</span><em class="sig-param">raster</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.get_raster_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a wkbPolygon geometry with the bounding rectangle of a raster calculated from its geotransform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>raster</strong> – A gdal.Image object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>An ogr.Geometry object containing a single wkbPolygon with four points defining the bounding rectangle of the</em></p></li>
<li><p><em>raster.</em></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Bounding rectangle is obtained from raster.GetGeoTransform(), with the top left corners rounded
down to the nearest multiple of of the resolution of the geotransform. This is to avoid rounding errors in
reprojected geotransformations.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.get_raster_intersection">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">get_raster_intersection</code><span class="sig-paren">(</span><em class="sig-param">raster1</em>, <em class="sig-param">raster2</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.get_raster_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a wkbPolygon geometry with the intersection of two raster bounding boxes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>raster2</strong> (<em>raster1</em><em>,</em>) – A gdal.Image() object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a ogr.Geometry object containing a single polygon</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.get_raster_size">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">get_raster_size</code><span class="sig-paren">(</span><em class="sig-param">raster</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.get_raster_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the width and height of a raster, in that raster’s units.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>raster</strong> – A gdal.Image object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A tuple containing (width, height)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.multiple_intersection">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">multiple_intersection</code><span class="sig-paren">(</span><em class="sig-param">polygons</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.multiple_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of polygons and returns a geometry representing the intersection of all of them</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>polygons</strong> – A list of ogr.Geometry objects, each containing a single polygon.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>An ogr.Geometry object containing a single polygon</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.multiple_union">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">multiple_union</code><span class="sig-paren">(</span><em class="sig-param">polygons</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.multiple_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of polygons and returns a polygon of the union of their perimeter</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>polygons</strong> – A list of ogr.Geometry objects, each containing a single polygon.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>An ogr.Geometry object containing a single polygon</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.pixel_bounds_from_polygon">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">pixel_bounds_from_polygon</code><span class="sig-paren">(</span><em class="sig-param">raster</em>, <em class="sig-param">polygon</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.pixel_bounds_from_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the bounding box of the overlap between a raster and a polygon in the raster</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raster</strong> – A gdal raster object</p></li>
<li><p><strong>polygon</strong> – A ogr.Geometry object containing a single polygon</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A tuple (x_min, x_max, y_min, y_max)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.pixel_to_point_coordinates">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">pixel_to_point_coordinates</code><span class="sig-paren">(</span><em class="sig-param">pixel</em>, <em class="sig-param">GT</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.pixel_to_point_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pixel and a geotransformation, returns the picaltion of that pixel’s top left corner in the projection
used by the geotransform.
NOTE: At present, this takes input in the form of y,x! This is opposite to the output of point_to_pixel_coordinates!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pixel</strong> – A tuple (y, x) of the coordinates of the pixel</p></li>
<li><p><strong>GT</strong> – A six-element numpy array containing a geotransform</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A tuple containing the geographic coordinates of the top-left corner of the pixel.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.point_to_pixel_coordinates">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">point_to_pixel_coordinates</code><span class="sig-paren">(</span><em class="sig-param">raster</em>, <em class="sig-param">point</em>, <em class="sig-param">oob_fail=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.point_to_pixel_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns a tuple (x_pixel, y_pixel) in a georaster raster corresponding to the geographic point in a projection.</dt><dd><p>Assumes raster is north-up non rotated.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raster</strong> – A gdal raster object</p></li>
<li><p><strong>point</strong> – <dl class="simple">
<dt>One of:</dt><dd><p>A well-known text string of a single point
An iterable of the form (x,y)
An ogr.Geometry object containing a single point</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A tuple of (x_pixel, y_pixel), containing the indicies of the point in the raster.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The equation is a rearrangement of the section on affinine geotransform in <a class="reference external" href="http://www.gdal.org/gdal_datamodel.html">http://www.gdal.org/gdal_datamodel.html</a></p>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.reproject_geotransform">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">reproject_geotransform</code><span class="sig-paren">(</span><em class="sig-param">in_gt</em>, <em class="sig-param">old_proj_wkt</em>, <em class="sig-param">new_proj_wkt</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.reproject_geotransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Reprojects a geotransform from the old projection to a new projection. See
[<a class="reference external" href="https://gdal.org/user/raster_data_model.html">https://gdal.org/user/raster_data_model.html</a>]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_gt</strong> – A six-element numpy array, usually an output from gdal_image.GetGeoTransform()</p></li>
<li><p><strong>old_proj_wkt</strong> – The projection of the old geotransform in well-known text.</p></li>
<li><p><strong>new_proj_wkt</strong> – The projection of the new geotrasform in well-known text.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The geotransform in the new projection</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>out_gt</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.coordinate_manipulation.write_geometry">
<code class="sig-prename descclassname">pyeo.coordinate_manipulation.</code><code class="sig-name descname">write_geometry</code><span class="sig-paren">(</span><em class="sig-param">geometry</em>, <em class="sig-param">out_path</em>, <em class="sig-param">srs_id=4326</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.coordinate_manipulation.write_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the geometry in an ogr.Geometry object to a shapefile.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geometry</strong> – An ogr.Geometry object</p></li>
<li><p><strong>out_path</strong> – The location to save the output shapefile</p></li>
<li><p><strong>srs_id</strong> – The projection of the output shapefile. Can be an EPSG number or a WKT string.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The shapefile consists of one layer named ‘geometry’.</p>
</dd></dl>

</div>
<span class="target" id="module-pyeo.filesystem_utilities"></span><div class="section" id="pyeo-filesystem-utilities">
<h2>pyeo.filesystem_utilities<a class="headerlink" href="#pyeo-filesystem-utilities" title="Permalink to this headline">¶</a></h2>
<p>Contains functions for sorting, creating and comparing images as part of the filesystem. Includes any function
that works on a generic pyeo timestamp and sentinel 2 functions.</p>
<dl class="function">
<dt id="pyeo.filesystem_utilities.check_for_invalid_l1_data">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">check_for_invalid_l1_data</code><span class="sig-paren">(</span><em class="sig-param">l1_SAFE_file</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.check_for_invalid_l1_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the existance of the specified resolution of imagery. Returns True with a warning if passed
an invalid SAFE directory; this will prevent disconnected files from being deleted.
Retuns 1 if imagery is valid, 0 if not and 2 if not a safe-file</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.check_for_invalid_l2_data">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">check_for_invalid_l2_data</code><span class="sig-paren">(</span><em class="sig-param">l2_SAFE_file</em>, <em class="sig-param">resolution='10m'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.check_for_invalid_l2_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the existance of the specified resolution of imagery. Returns a True-value with a warning if passed
an invalid SAFE directory; this will prevent disconnected files from being deleted.
Retuns 1 if imagery is valid, 0 if not and 2 if not a safe-file</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.clean_aoi">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">clean_aoi</code><span class="sig-paren">(</span><em class="sig-param">aoi_dir</em>, <em class="sig-param">images_to_keep=4</em>, <em class="sig-param">warning=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.clean_aoi" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all but the last images_to_keep newest images in the L1, L2, merged, stacked and
composite directories. Will not affect the output folder.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.clean_l2_data">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">clean_l2_data</code><span class="sig-paren">(</span><em class="sig-param">l2_SAFE_file</em>, <em class="sig-param">resolution='10m'</em>, <em class="sig-param">warning=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.clean_l2_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes any directories that don’t have band 2, 3, 4 or 8 in the specified resolution folder
If warning=True, prompts first.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.clean_l2_dir">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">clean_l2_dir</code><span class="sig-paren">(</span><em class="sig-param">l2_dir</em>, <em class="sig-param">resolution='10m'</em>, <em class="sig-param">warning=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.clean_l2_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls clean_l2_data on every SAFE file in l2_dir</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.create_file_structure">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">create_file_structure</code><span class="sig-paren">(</span><em class="sig-param">root</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.create_file_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the file structure if it doesn’t exist already</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_change_detection_dates">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_change_detection_dates</code><span class="sig-paren">(</span><em class="sig-param">image_name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_change_detection_dates" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the source filepath and extracts the before_date and after_date dates from in, in that order.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_image_acquisition_time">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_image_acquisition_time</code><span class="sig-paren">(</span><em class="sig-param">image_name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_image_acquisition_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the datetime object from a .safe filename of a planet image. No test. Returns None if no timestamp present</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_l1_safe_file">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_l1_safe_file</code><span class="sig-paren">(</span><em class="sig-param">image_name</em>, <em class="sig-param">l1_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_l1_safe_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the path to the L1 .SAFE directory of image. Gets from granule and timestamp. image_name can be a path or
a filename</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_l2_safe_file">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_l2_safe_file</code><span class="sig-paren">(</span><em class="sig-param">image_name</em>, <em class="sig-param">l2_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_l2_safe_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the path to the L2 .SAFE directory of image. Gets from granule and timestamp. image_name can be a path or
a filename</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_mask_path">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_mask_path</code><span class="sig-paren">(</span><em class="sig-param">image_path</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_mask_path" title="Permalink to this definition">¶</a></dt>
<dd><p>A gdal mask is an image with the same name as the image it’s masking, but with a .msk extension</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_preceding_image_path">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_preceding_image_path</code><span class="sig-paren">(</span><em class="sig-param">target_image_name</em>, <em class="sig-param">search_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_preceding_image_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the path to the image in search_dir preceding the image called image_name</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_pyeo_timestamp">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_pyeo_timestamp</code><span class="sig-paren">(</span><em class="sig-param">image_name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_pyeo_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all timestamps in a Pyeo image.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_related_images">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_related_images</code><span class="sig-paren">(</span><em class="sig-param">target_image_name</em>, <em class="sig-param">project_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_related_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the paths of all images related to that one in a project, by timestamp</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_sen_2_granule_id">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_sen_2_granule_id</code><span class="sig-paren">(</span><em class="sig-param">safe_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_sen_2_granule_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unique ID of a Sentinel 2 granule from a SAFE directory path</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_sen_2_image_orbit">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_sen_2_image_orbit</code><span class="sig-paren">(</span><em class="sig-param">image_name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_sen_2_image_orbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the relative orbit number of a Sentinel 2 image</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_sen_2_image_tile">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_sen_2_image_tile</code><span class="sig-paren">(</span><em class="sig-param">image_name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_sen_2_image_tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the tile number of a Sentinel 2 image or path</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_sen_2_image_timestamp">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_sen_2_image_timestamp</code><span class="sig-paren">(</span><em class="sig-param">image_name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_sen_2_image_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the timestamps part of a Sentinel 2 image</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.get_sen_2_tiles">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">get_sen_2_tiles</code><span class="sig-paren">(</span><em class="sig-param">image_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.get_sen_2_tiles" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the list of tiles present in the directory</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.init_log">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">init_log</code><span class="sig-paren">(</span><em class="sig-param">log_path</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.init_log" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Sets up the log format and log handlers; one for stdout and to write to a file, ‘log_path’.</dt><dd><p>Returns the log for the calling script</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>log_path</strong> – A location to save the log entries to</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A log object.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.is_tif">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">is_tif</code><span class="sig-paren">(</span><em class="sig-param">image_string</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.is_tif" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if image ends with .tif</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.filesystem_utilities.sort_by_timestamp">
<code class="sig-prename descclassname">pyeo.filesystem_utilities.</code><code class="sig-name descname">sort_by_timestamp</code><span class="sig-paren">(</span><em class="sig-param">strings</em>, <em class="sig-param">recent_first=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.filesystem_utilities.sort_by_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of strings that contain sen2 timestamps and returns them sorted, most recent first. Does not
guarantee ordering of strings with the same timestamp. Removes any string that does not contain a timestamp</p>
</dd></dl>

</div>
<span class="target" id="module-pyeo.queries_and_downloads"></span><div class="section" id="pyeo-queries-and-downloads">
<h2>pyeo.queries_and_downloads<a class="headerlink" href="#pyeo-queries-and-downloads" title="Permalink to this headline">¶</a></h2>
<p>Functions for querying, filtering and downloading data.</p>
</div>
<div class="section" id="safe-files">
<h2>SAFE files<a class="headerlink" href="#safe-files" title="Permalink to this headline">¶</a></h2>
<p>Sentinel 2 data is downloaded in the form of a .SAFE file; all download functions will end with data in this structure.
This is a directory structure that contains the imagery, metadata and supplementary data of a Sentinel 2 image. The
rasters themeselves are the in the GRANULE/[granule_id]/IMG_DATA/[resolution]/ folder; each band is contained in
its own .jp2 file. For full details, see <a class="reference external" href="https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi/data-formats">https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi/data-formats</a></p>
<p>There are two ways to refer to a given Sentinel-2 products: the UUID and the product ID.
The UUID is a set of five five-character strings (EXMAPLE HERE)
The product ID is a human-readable string (more or less) containing all the information needed for unique identification
of an product, split by the underscore character. For more information on the structure of a product ID,
see (EXAMPLE HERE)</p>
</div>
<div class="section" id="query-data-structure">
<h2>Query data structure<a class="headerlink" href="#query-data-structure" title="Permalink to this headline">¶</a></h2>
<p>All query functions return a dictionary. The key of the dictionary is the UUID of the product id; the product is
a further set of nested dictionaries containing information about the product to be downloaded. (PUT STRUCTURE HERE)</p>
</div>
<div class="section" id="data-download-sources">
<h2>Data download sources<a class="headerlink" href="#data-download-sources" title="Permalink to this headline">¶</a></h2>
<p>This library presently offers two options for download sources; Scihub and Amazon Web Services. If in doubt, use Scihub.</p>
<div class="section" id="scihub">
<h3>Scihub<a class="headerlink" href="#scihub" title="Permalink to this headline">¶</a></h3>
<p>The Copernicus Open-Access Hub is the default option for downloading sentinel-2 images. Images are downloaded in .zip
format, and then automatically unzipped. Users are required to register with a username and password before downloading,
and there is a limit to no more than two concurrent downloads per username at a time. Scihub is entirely free.</p>
</div>
<div class="section" id="aws">
<h3>AWS<a class="headerlink" href="#aws" title="Permalink to this headline">¶</a></h3>
<p>Sentinel data is also publically hosted on Amazon Web Services. This storage is provided by Sinergise, and is normally
updated a few hours after new products are made available. There is a small charge associated with downloading this
data. To access the AWS repository, you are required to register an Amazon Web Services account (including providing
payment details) and obtain an API key for that account. See <a class="reference external" href="https://aws.amazon.com/s3/pricing/">https://aws.amazon.com/s3/pricing/</a> for pricing details;
the relevant table is Data Transfer Pricing for the EU (Frankfurt) region. There is no limit to the concurrent downloads
for the AWS bucket.</p>
<dl class="function">
<dt id="pyeo.queries_and_downloads.activate_and_dl_planet_item">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">activate_and_dl_planet_item</code><span class="sig-paren">(</span><em class="sig-param">session</em>, <em class="sig-param">item</em>, <em class="sig-param">asset_type</em>, <em class="sig-param">file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.activate_and_dl_planet_item" title="Permalink to this definition">¶</a></dt>
<dd><p>Activates and downloads a single planet item</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.build_search_request">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">build_search_request</code><span class="sig-paren">(</span><em class="sig-param">aoi</em>, <em class="sig-param">start_date</em>, <em class="sig-param">end_date</em>, <em class="sig-param">item_type</em>, <em class="sig-param">search_name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.build_search_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a search request for the planet API</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.check_for_s2_data_by_date">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">check_for_s2_data_by_date</code><span class="sig-paren">(</span><em class="sig-param">aoi_path</em>, <em class="sig-param">start_date</em>, <em class="sig-param">end_date</em>, <em class="sig-param">conf</em>, <em class="sig-param">cloud_cover=50</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.check_for_s2_data_by_date" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets all the products between start_date and end_date. Wraps sent2_query to avoid having passwords and
long-format timestamps in code.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aoi_path</strong> – Path to a geojson file containing a polygon of the outline of the area you wish to download.
See www.geojson.io for a tool to build these.</p></li>
<li><p><strong>start_date</strong> – Start date in the format yyyymmdd.</p></li>
<li><p><strong>end_date</strong> – End date of the query in the format yyyymmdd</p></li>
<li><p><strong>conf</strong> – Output from a configuration file containing your username and password for the ESA hub.
If needed, this can be dummied with a dictionary of the following format:
conf={‘sent_2’:{‘user’:’your_username’, ‘pass’:’your_pass’}}</p></li>
<li><p><strong>cloud_cover</strong> – The maximem level of cloud cover in images to be downloaded.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.do_quick_search">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">do_quick_search</code><span class="sig-paren">(</span><em class="sig-param">session</em>, <em class="sig-param">search_request</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.do_quick_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries the quick search; returns a dict of features</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.do_saved_search">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">do_saved_search</code><span class="sig-paren">(</span><em class="sig-param">session</em>, <em class="sig-param">search_request</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.do_saved_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Does a saved search; this doesn’t seem to work yet.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.download_blob_from_google">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">download_blob_from_google</code><span class="sig-paren">(</span><em class="sig-param">bucket</em>, <em class="sig-param">object_prefix</em>, <em class="sig-param">out_folder</em>, <em class="sig-param">s2_object</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.download_blob_from_google" title="Permalink to this definition">¶</a></dt>
<dd><p>Still experimental.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.download_from_aws_with_rollback">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">download_from_aws_with_rollback</code><span class="sig-paren">(</span><em class="sig-param">product_id</em>, <em class="sig-param">folder</em>, <em class="sig-param">uuid</em>, <em class="sig-param">user</em>, <em class="sig-param">passwd</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.download_from_aws_with_rollback" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to download a single product from AWS using product_id; if not found, rolls back to Scihub using the UUID</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product_id</strong> – The product ID (“<a href="#id7"><span class="problematic" id="id8">L2A_</span></a>…”)</p></li>
<li><p><strong>folder</strong> – The folder to download the .SAFE file to.</p></li>
<li><p><strong>uuid</strong> – The product UUID (4dfB4-432df….)</p></li>
<li><p><strong>user</strong> – Scihub username</p></li>
<li><p><strong>passwd</strong> – Scihub password</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.download_from_google_cloud">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">download_from_google_cloud</code><span class="sig-paren">(</span><em class="sig-param">product_ids</em>, <em class="sig-param">out_folder</em>, <em class="sig-param">redownload=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.download_from_google_cloud" title="Permalink to this definition">¶</a></dt>
<dd><p>Still experimental.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.download_from_scihub">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">download_from_scihub</code><span class="sig-paren">(</span><em class="sig-param">product_uuid</em>, <em class="sig-param">out_folder</em>, <em class="sig-param">user</em>, <em class="sig-param">passwd</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.download_from_scihub" title="Permalink to this definition">¶</a></dt>
<dd><p>Downloads and unzips product_uuid from scihub</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product_uuid</strong> – The product UUID (4dfB4-432df….)</p></li>
<li><p><strong>out_folder</strong> – The folder to save the .SAFE file to</p></li>
<li><p><strong>user</strong> – Scihub username</p></li>
<li><p><strong>passwd</strong> – Scihub password</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If interrupted mid-download, there will be a .incomplete file in the download folder. You might need to remove
this for further processing.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.download_planet_image_on_day">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">download_planet_image_on_day</code><span class="sig-paren">(</span><em class="sig-param">aoi_path</em>, <em class="sig-param">date</em>, <em class="sig-param">out_path</em>, <em class="sig-param">api_key</em>, <em class="sig-param">item_type='PSScene4Band'</em>, <em class="sig-param">search_name='auto'</em>, <em class="sig-param">asset_type='analytic'</em>, <em class="sig-param">threads=5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.download_planet_image_on_day" title="Permalink to this definition">¶</a></dt>
<dd><p>Queries and downloads all images on the date in the aoi given</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.download_s2_data">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">download_s2_data</code><span class="sig-paren">(</span><em class="sig-param">new_data</em>, <em class="sig-param">l1_dir</em>, <em class="sig-param">l2_dir</em>, <em class="sig-param">source='scihub'</em>, <em class="sig-param">user=None</em>, <em class="sig-param">passwd=None</em>, <em class="sig-param">try_scihub_on_fail=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.download_s2_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Downloads S2 imagery from AWS, google_cloud or scihub. new_data is a dict from Sentinel_2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_data</strong> – A query dictionary contining the products you want to download</p></li>
<li><p><strong>l1_dir</strong> – The directory to download level 1 products to.</p></li>
<li><p><strong>l2_dir</strong> – The directory to download level 2 products to.</p></li>
<li><p><strong>source</strong> – The source to download the data from. Can be ‘scihub’ or ‘aws’; see section introduction for details</p></li>
<li><p><strong>user</strong> – The username for sentinelhub</p></li>
<li><p><strong>passwd</strong> – The password for sentinelheub</p></li>
<li><p><strong>try_scihub_on_fail</strong> – If true, this function will roll back to downloading from Scihub on a failure of any other downloader.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>BadDataSource</strong> – Raised when passed either a bad datasource or a bad image ID</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.filter_non_matching_s2_data">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">filter_non_matching_s2_data</code><span class="sig-paren">(</span><em class="sig-param">query_output</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.filter_non_matching_s2_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters a query such that it only contains paired level 1 and level 2 data products.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>query_output</strong> – Query list</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A dictionary of products contaiing only L1 and L2 data.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.filter_to_l1_data">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">filter_to_l1_data</code><span class="sig-paren">(</span><em class="sig-param">query_output</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.filter_to_l1_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes list of products from check_for_s2_data_by_date and removes all non Level 1 products.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>query_output</strong> – A dictionary of products</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A dictionary of products containing only the L1C data products</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.filter_to_l2_data">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">filter_to_l2_data</code><span class="sig-paren">(</span><em class="sig-param">query_output</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.filter_to_l2_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes list of products from check_for_s2_data_by_date and removes all non Level 2A products.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>query_output</strong> – A dictionary of products</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A dictionary of products containing only the L2A data products</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.get_granule_identifiers">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">get_granule_identifiers</code><span class="sig-paren">(</span><em class="sig-param">safe_product_id</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.get_granule_identifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the parts of a S2 name that uniquely identify that granulate at a moment in time
:param safe_product_id: The filename of a SAFE product</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>satellite</em> – A string of either “L2A” or “L2B”</p></li>
<li><p><em>intake_date</em> – The timestamp of the data intoake of this granule</p></li>
<li><p><em>orbit number</em> – The orbit number of this granule</p></li>
<li><p><em>granule</em> – The ID of this granule</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.get_paginated_items">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">get_paginated_items</code><span class="sig-paren">(</span><em class="sig-param">session</em>, <em class="sig-param">search_id</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.get_paginated_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Let’s leave this out for now.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.get_planet_product_path">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">get_planet_product_path</code><span class="sig-paren">(</span><em class="sig-param">planet_dir</em>, <em class="sig-param">product</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.get_planet_product_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the path to a Planet product within a Planet directory</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.get_query_datatake">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">get_query_datatake</code><span class="sig-paren">(</span><em class="sig-param">query_item</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.get_query_datatake" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the datatake timestamp of a query item.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>query_item</strong> – An item from a query results dictionary.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>The timestamp of that item’s datatake.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.get_query_granule">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">get_query_granule</code><span class="sig-paren">(</span><em class="sig-param">query_item</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.get_query_granule" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the granule ID (ex: 48MXU) of a query</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>query_item</strong> – An item from a query results dictionary.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>The granule ID of that item.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.get_query_level">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">get_query_level</code><span class="sig-paren">(</span><em class="sig-param">query_item</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.get_query_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the processing level of the query item.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>query_item</strong> – An item from a query results dictionary.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A string of either ‘Level-1C’ or ‘Level-2A’.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.get_query_processing_time">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">get_query_processing_time</code><span class="sig-paren">(</span><em class="sig-param">query_item</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.get_query_processing_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the processing timestamps of a query item</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>query_item</strong> – An item from a query results dictionary.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>The date processing timestamp in the format yyyymmddThhmmss (Ex</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>20190613T123002)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.load_api_key">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">load_api_key</code><span class="sig-paren">(</span><em class="sig-param">path_to_api</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.load_api_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an API key from a single-line text file containing that API</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path_to_api</strong> – The path a text file containing only the API key</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Returns the API key</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.planet_query">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">planet_query</code><span class="sig-paren">(</span><em class="sig-param">aoi_path</em>, <em class="sig-param">start_date</em>, <em class="sig-param">end_date</em>, <em class="sig-param">out_path</em>, <em class="sig-param">api_key</em>, <em class="sig-param">item_type='PSScene4Band'</em>, <em class="sig-param">search_name='auto'</em>, <em class="sig-param">asset_type='analytic'</em>, <em class="sig-param">threads=5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.planet_query" title="Permalink to this definition">¶</a></dt>
<dd><p>Downloads data from Planetlabs for a given time period in the given AOI</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aoi</strong> (<em>str</em>) – Filepath of a single-polygon geojson containing the aoi</p></li>
<li><p><strong>start_date</strong> (<em>str</em>) – the inclusive start of the time window in UTC format</p></li>
<li><p><strong>end_date</strong> (<em>str</em>) – the inclusive end of the time window in UTC format</p></li>
<li><p><strong>out_path</strong> (<em>filepath-like object</em>) – A path to the output folder
Any identically-named imagery will be overwritten</p></li>
<li><p><strong>item_type</strong> (<em>str</em>) – Image type to download (see Planet API docs)</p></li>
<li><p><strong>search_name</strong> (<em>str</em>) – A name to refer to the search (required for large searches)</p></li>
<li><p><strong>asset_type</strong> (<em>str</em>) – Planet asset type to download (see Planet API docs)</p></li>
<li><p><strong>threads</strong> (<em>int</em>) – The number of downloads to perform concurrently</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>IMPORTANT: Will not run for searches returning greater than 250 items.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.read_aoi">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">read_aoi</code><span class="sig-paren">(</span><em class="sig-param">aoi_path</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.read_aoi" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens the geojson file for the aoi. If FeatureCollection, return the first feature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>aoi_path</strong> – The path to the geojson file</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A dictionary translation of the feature inside the .json file</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.queries_and_downloads.sent2_query">
<code class="sig-prename descclassname">pyeo.queries_and_downloads.</code><code class="sig-name descname">sent2_query</code><span class="sig-paren">(</span><em class="sig-param">user</em>, <em class="sig-param">passwd</em>, <em class="sig-param">geojsonfile</em>, <em class="sig-param">start_date</em>, <em class="sig-param">end_date</em>, <em class="sig-param">cloud=50</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.queries_and_downloads.sent2_query" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetches a list of Sentienl-2 products</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>user</strong> (<em>string</em>) – Username for ESA hub. Register at <a class="reference external" href="https://scihub.copernicus.eu/dhus/#/home">https://scihub.copernicus.eu/dhus/#/home</a></p></li>
<li><p><strong>passwd</strong> (<em>string</em>) – password for the ESA Open Access hub</p></li>
<li><p><strong>geojsonfile</strong> (<em>string</em>) – Path to a geojson file containing a polygon of the outline of the area you wish to download.
See www.geojson.io for a tool to build these.</p></li>
<li><p><strong>start_date</strong> (<em>string</em>) – Date of beginning of search in the format YYYY-MM-DDThh:mm:ssZ (ISO standard)</p></li>
<li><p><strong>end_date</strong> (<em>string</em>) – Date of end of search in the format yyyy-mm-ddThh:mm:ssZ
See https://www.w3.org/TR/NOTE-datetime, or use cehck_for_s2_data_by_date</p></li>
<li><p><strong>cloud</strong> (<em>string</em><em> (</em><em>optional</em><em>)</em>) – The maximum cloud clover (as calculated by Copernicus) to download.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>A dictionary of Sentinel-2 granule products that are touched by your AOI polygon, keyed by product ID.</em></p></li>
<li><p><em>Returns both level 1 and level 2 data.</em></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If you get a ‘request too long’ error, it is likely that your polygon is too complex. The following functions
download by granule; there is no need to have a precise polygon at this stage.</p>
</dd></dl>

</div>
</div>
<span class="target" id="module-pyeo.raster_manipulation"></span><div class="section" id="pyeo-raster-manipulation">
<h2>pyeo.raster_manipulation<a class="headerlink" href="#pyeo-raster-manipulation" title="Permalink to this headline">¶</a></h2>
<p>Functions for working with raster data.</p>
<dl class="function">
<dt id="pyeo.raster_manipulation.apply_array_image_mask">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">apply_array_image_mask</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">mask</em>, <em class="sig-param">fill_value=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.apply_array_image_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a mask of (y,x) to an image array of (bands, y, x). Replaces any masked pixels with fill_value
Mask is an a 2 dimensional array of 1 ( unmasked) and 0 (masked)</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.apply_fmask">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">apply_fmask</code><span class="sig-paren">(</span><em class="sig-param">in_safe_dir</em>, <em class="sig-param">out_file</em>, <em class="sig-param">fmask_command='fmask_sentinel2Stacked.py'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.apply_fmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls fmask to create a new mask for L1 data</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.apply_sen2cor">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">apply_sen2cor</code><span class="sig-paren">(</span><em class="sig-param">image_path</em>, <em class="sig-param">sen2cor_path</em>, <em class="sig-param">delete_unprocessed_image=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.apply_sen2cor" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies sen2cor to the SAFE file at image_path. Returns the path to the new product.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.atmospheric_correction">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">atmospheric_correction</code><span class="sig-paren">(</span><em class="sig-param">in_directory</em>, <em class="sig-param">out_directory</em>, <em class="sig-param">sen2cor_path</em>, <em class="sig-param">delete_unprocessed_image=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.atmospheric_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies Sen2cor cloud correction to level 1C images</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.buffer_mask_in_place">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">buffer_mask_in_place</code><span class="sig-paren">(</span><em class="sig-param">mask_path</em>, <em class="sig-param">buffer_size</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.buffer_mask_in_place" title="Permalink to this definition">¶</a></dt>
<dd><p>Expands a mask in-place, overwriting the previous mask</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.clip_raster">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">clip_raster</code><span class="sig-paren">(</span><em class="sig-param">raster_path</em>, <em class="sig-param">aoi_path</em>, <em class="sig-param">out_path</em>, <em class="sig-param">srs_id=4326</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.clip_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Clips a raster at raster_path to a shapefile given by aoi_path. Assumes a shapefile only has one polygon.
Will np.floor() when converting from geo to pixel units and np.absolute() y resolution form geotransform.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.combine_masks">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">combine_masks</code><span class="sig-paren">(</span><em class="sig-param">mask_paths</em>, <em class="sig-param">out_path</em>, <em class="sig-param">combination_func='and'</em>, <em class="sig-param">geometry_func='intersect'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.combine_masks" title="Permalink to this definition">¶</a></dt>
<dd><p>ORs or ANDs several masks. Gets metadata from top mask. Assumes that masks are a
Python true or false. Also assumes that all masks are the same projection for now.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.composite_directory">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">composite_directory</code><span class="sig-paren">(</span><em class="sig-param">image_dir</em>, <em class="sig-param">composite_out_dir</em>, <em class="sig-param">format='GTiff'</em>, <em class="sig-param">generate_date_images=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.composite_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Composites every image in image_dir, assumes all have associated masks.  Will
place a file named composite_[last image date].tif inside composite_out_dir</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.composite_images_with_mask">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">composite_images_with_mask</code><span class="sig-paren">(</span><em class="sig-param">in_raster_path_list</em>, <em class="sig-param">composite_out_path</em>, <em class="sig-param">format='GTiff'</em>, <em class="sig-param">generate_date_image=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.composite_images_with_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Works down in_raster_path_list, updating pixels in composite_out_path if not masked. Masks are assumed to
be a binary .msk file with the same path as their corresponding image. All images must have the same
number of layers and resolution, but do not have to be perfectly on top of each other. If it does not exist,
composite_out_path will be created. Takes projection, resolution, ect from first band of first raster in list.
Will reproject images and masks if they do not match initial raster.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.create_mask_from_class_map">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">create_mask_from_class_map</code><span class="sig-paren">(</span><em class="sig-param">class_map_path</em>, <em class="sig-param">out_path</em>, <em class="sig-param">classes_of_interest</em>, <em class="sig-param">buffer_size=0</em>, <em class="sig-param">out_resolution=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.create_mask_from_class_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a mask from a classification mask: 1 for each pixel containing one of classes_of_interest, otherwise 0</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.create_mask_from_confidence_layer">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">create_mask_from_confidence_layer</code><span class="sig-paren">(</span><em class="sig-param">l2_safe_path</em>, <em class="sig-param">out_path</em>, <em class="sig-param">cloud_conf_threshold=0</em>, <em class="sig-param">buffer_size=3</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.create_mask_from_confidence_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a multiplicative binary mask where cloudy pixels are 0 and non-cloudy pixels are 1. If
cloud_conf_threshold = 0, use scl mask else use confidence image</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.create_mask_from_model">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">create_mask_from_model</code><span class="sig-paren">(</span><em class="sig-param">image_path</em>, <em class="sig-param">model_path</em>, <em class="sig-param">model_clear=0</em>, <em class="sig-param">num_chunks=10</em>, <em class="sig-param">buffer_size=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.create_mask_from_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a multiplicative mask (0 for cloud, shadow or haze, 1 for clear) built from the model at model_path.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.create_matching_dataset">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">create_matching_dataset</code><span class="sig-paren">(</span><em class="sig-param">in_dataset</em>, <em class="sig-param">out_path</em>, <em class="sig-param">format='GTiff'</em>, <em class="sig-param">bands=1</em>, <em class="sig-param">datatype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.create_matching_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an empty gdal dataset with the same dimensions, projection and geotransform. Defaults to 1 band.
Datatype is set from the first layer of in_dataset if unspecified</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.create_new_image_from_polygon">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">create_new_image_from_polygon</code><span class="sig-paren">(</span><em class="sig-param">polygon</em>, <em class="sig-param">out_path</em>, <em class="sig-param">x_res</em>, <em class="sig-param">y_res</em>, <em class="sig-param">bands</em>, <em class="sig-param">projection</em>, <em class="sig-param">format='GTiff'</em>, <em class="sig-param">datatype=5</em>, <em class="sig-param">nodata=-9999</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.create_new_image_from_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an empty image of the extent of input polygon</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.create_new_stacks">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">create_new_stacks</code><span class="sig-paren">(</span><em class="sig-param">image_dir</em>, <em class="sig-param">stack_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.create_new_stacks" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates new stacks with with adjacent image acquisition dates. Threshold; how small a part
of the latest_image will be before it’s considered to be fully processed.
New_image_name must exist inside image_dir.</p>
<dl class="simple">
<dt>Step 1: Sort directory as follows:</dt><dd><p>Relative Orbit number (RO4O), then Tile Number (T15PXT), then
Datatake sensing start date (YYYYMMDD) and time(THHMMSS).
newest first.</p>
</dd>
<dt>Step 2: For each tile number:</dt><dd><p>new_data_polygon = bounds(new_image_name)</p>
</dd>
<dt>Step 3: For each tiff image coverring that tile, work backwards in time:</dt><dd><ol class="loweralpha simple">
<li><p>Check if it intersects new_data_polygon</p></li>
<li><p>If it does
- add to a to_be_stacked list,
- subtract it’s bounding box from new_data_polygon.</p></li>
<li><p>If new_data_polygon drops having a total area less than threshold, stop.</p></li>
</ol>
</dd>
</dl>
<p>Step 4: Stack new rasters for each tile in new_data list.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.filter_by_class_map">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">filter_by_class_map</code><span class="sig-paren">(</span><em class="sig-param">image_path</em>, <em class="sig-param">class_map_path</em>, <em class="sig-param">out_map_path</em>, <em class="sig-param">classes_of_interest</em>, <em class="sig-param">out_resolution=10</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.filter_by_class_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters class_map_path for pixels in filter_map_path containing only classes_of_interest.
Assumes that filter_map_path and class_map_path are same resolution and projection.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.flatten_probability_image">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">flatten_probability_image</code><span class="sig-paren">(</span><em class="sig-param">prob_image</em>, <em class="sig-param">out_path</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.flatten_probability_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a single-band raster containing the highest certainties in a input probablility raster</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.get_masked_array">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">get_masked_array</code><span class="sig-paren">(</span><em class="sig-param">raster</em>, <em class="sig-param">mask_path</em>, <em class="sig-param">fill_value=-9999</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.get_masked_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a numpy.mask masked array for the raster.
Masked pixels are FALSE in the mask image (multiplicateive map),
but TRUE in the masked_array (nodata pixels)</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.mosaic_images">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">mosaic_images</code><span class="sig-paren">(</span><em class="sig-param">raster_paths</em>, <em class="sig-param">out_raster_file</em>, <em class="sig-param">format='GTiff'</em>, <em class="sig-param">datatype=5</em>, <em class="sig-param">nodata=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.mosaic_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Mosaics multiple images with the same number of layers into one single image. Overwrites
overlapping pixels with the value furthest down raster_paths. Takes projection from the first
raster.</p>
<p>TODO: consider using GDAL:</p>
<dl class="simple">
<dt>gdal_merge.py [-o out_filename] [-of out_format] [-co NAME=VALUE]*</dt><dd><p>[-ps pixelsize_x pixelsize_y] [-tap] [-separate] [-q] [-v] [-pct]
[-ul_lr ulx uly lrx lry] [-init “value [value…]”]
[-n nodata_value] [-a_nodata output_nodata_value]
[-ot datatype] [-createonly] input_files</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.open_dataset_from_safe">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">open_dataset_from_safe</code><span class="sig-paren">(</span><em class="sig-param">safe_file_path</em>, <em class="sig-param">band</em>, <em class="sig-param">resolution='10m'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.open_dataset_from_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens a dataset given a safe file. Give band as a string.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.preprocess_sen2_images">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">preprocess_sen2_images</code><span class="sig-paren">(</span><em class="sig-param">l2_dir</em>, <em class="sig-param">out_dir</em>, <em class="sig-param">l1_dir</em>, <em class="sig-param">cloud_threshold=60</em>, <em class="sig-param">buffer_size=0</em>, <em class="sig-param">epsg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.preprocess_sen2_images" title="Permalink to this definition">¶</a></dt>
<dd><p>For every .SAFE folder in in_dir, stacks band 2,3,4 and 8  bands into a single geotif, creates a cloudmask from
the combined fmask and sen2cor cloudmasks and reprojects to a given EPSG if provided</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.raster_sum">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">raster_sum</code><span class="sig-paren">(</span><em class="sig-param">inRstList</em>, <em class="sig-param">outFn</em>, <em class="sig-param">outFmt='GTiff'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.raster_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a raster stack from a list of rasters. Adapted from Chris Gerard’s
book ‘Geoprocessing with Python’. The out put data type is the same as the input data type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inRstList</strong> (<em>str</em>) – List of rasters to stack.</p></li>
<li><p><strong>outFmt</strong> (<em>str</em>) – String specifying the input data format e.g. ‘GTiff’ or ‘VRT’.</p></li>
<li><p><strong>outFn</strong> (<em>str</em>) – Filename output as str including directory else image will be</p></li>
</ul>
</dd>
</dl>
<p>written to current working directory.</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.raster_to_array">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">raster_to_array</code><span class="sig-paren">(</span><em class="sig-param">rst_pth</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.raster_to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads in a raster file and returns a N-dimensional array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rst_pth</strong> (<em>str</em>) – Path to input raster.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>N-dimensional array.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.reproject_directory">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">reproject_directory</code><span class="sig-paren">(</span><em class="sig-param">in_dir</em>, <em class="sig-param">out_dir</em>, <em class="sig-param">new_projection</em>, <em class="sig-param">extension='.tif'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.reproject_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Reprojects every file ending with extension to new_projection and saves in out_dir</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.reproject_image">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">reproject_image</code><span class="sig-paren">(</span><em class="sig-param">in_raster</em>, <em class="sig-param">out_raster_path</em>, <em class="sig-param">new_projection</em>, <em class="sig-param">driver='GTiff'</em>, <em class="sig-param">memory=2000.0</em>, <em class="sig-param">do_post_resample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.reproject_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new, reprojected image from in_raster. Wraps gdal.ReprojectImage function. Will round projection
back to whatever 2gb memory limit by default (because it works in most places)</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.resample_image_in_place">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">resample_image_in_place</code><span class="sig-paren">(</span><em class="sig-param">image_path</em>, <em class="sig-param">new_res</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.resample_image_in_place" title="Permalink to this definition">¶</a></dt>
<dd><p>Resamples an image in-place using gdalwarp to new_res in metres</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.save_array_as_image">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">save_array_as_image</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">path</em>, <em class="sig-param">geotransform</em>, <em class="sig-param">projection</em>, <em class="sig-param">format='GTiff'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.save_array_as_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves a given array as a geospatial image in the format ‘format’
Array must be gdal format: [bands, y, x]. Returns the gdal object</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.stack_and_trim_images">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">stack_and_trim_images</code><span class="sig-paren">(</span><em class="sig-param">old_image_path</em>, <em class="sig-param">new_image_path</em>, <em class="sig-param">aoi_path</em>, <em class="sig-param">out_image</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.stack_and_trim_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Stacks an old and new S2 image and trims to within an aoi</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.stack_image_with_composite">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">stack_image_with_composite</code><span class="sig-paren">(</span><em class="sig-param">image_path</em>, <em class="sig-param">composite_path</em>, <em class="sig-param">out_dir</em>, <em class="sig-param">create_combined_mask=True</em>, <em class="sig-param">skip_if_exists=True</em>, <em class="sig-param">invert_stack=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.stack_image_with_composite" title="Permalink to this definition">¶</a></dt>
<dd><p>Stacks an image with a cloud-free composite</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.stack_images">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">stack_images</code><span class="sig-paren">(</span><em class="sig-param">raster_paths</em>, <em class="sig-param">out_raster_path</em>, <em class="sig-param">geometry_mode='intersect'</em>, <em class="sig-param">format='GTiff'</em>, <em class="sig-param">datatype=5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.stack_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Stacks multiple images in image_paths together, using the information of the top image.
geometry_mode can be “union” or “intersect”</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.stack_old_and_new_images">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">stack_old_and_new_images</code><span class="sig-paren">(</span><em class="sig-param">old_image_path</em>, <em class="sig-param">new_image_path</em>, <em class="sig-param">out_dir</em>, <em class="sig-param">create_combined_mask=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.stack_old_and_new_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Stacks two images with the same tile
Names the result with the two timestamps.
First, decompose the granule ID into its components:
e.g. S2A, MSIL2A, 20180301, T162211, N0206, R040, T15PXT, 20180301, T194348
are the mission ID(S2A/S2B), product level(L2A), datatake sensing start date (YYYYMMDD) and time(THHMMSS),
the Processing Baseline number (N0206), Relative Orbit number (RO4O), Tile Number field (T15PXT),
followed by processing run date and then time</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.stack_sentinel_2_bands">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">stack_sentinel_2_bands</code><span class="sig-paren">(</span><em class="sig-param">safe_dir</em>, <em class="sig-param">out_image_path</em>, <em class="sig-param">band='10m'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.stack_sentinel_2_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Stacks the contents of a .SAFE granule directory into a single geotiff</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.raster_manipulation.trim_image">
<code class="sig-prename descclassname">pyeo.raster_manipulation.</code><code class="sig-name descname">trim_image</code><span class="sig-paren">(</span><em class="sig-param">in_raster_path</em>, <em class="sig-param">out_raster_path</em>, <em class="sig-param">polygon</em>, <em class="sig-param">format='GTiff'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.raster_manipulation.trim_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Trims image to polygon</p>
</dd></dl>

</div>
<span class="target" id="module-pyeo.validation"></span><div class="section" id="pyeo-validaion">
<h2>pyeo.validaion<a class="headerlink" href="#pyeo-validaion" title="Permalink to this headline">¶</a></h2>
<p>A small set of functions for producing validation points from maps</p>
<dl class="function">
<dt id="pyeo.validation.allocate_category_sample_sizes">
<code class="sig-prename descclassname">pyeo.validation.</code><code class="sig-name descname">allocate_category_sample_sizes</code><span class="sig-paren">(</span><em class="sig-param">total_sample_size</em>, <em class="sig-param">user_accuracy</em>, <em class="sig-param">class_total_sizes</em>, <em class="sig-param">variance_tolerance</em>, <em class="sig-param">allocate_type='olofsson'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.validation.allocate_category_sample_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates a number of pixels to sample per class that will fulfil the parameters given</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>total_sample_size</strong> (<em>The total number of validation points requested</em><em> (</em><em>from cal_total_sample_size</em><em>)</em>) – </p></li>
<li><p><strong>user_accuracy</strong> (<em>Dictionary of estimated user accuracies for classes in map</em><em> (</em><em>between 0 and 1</em><em>)</em>) – </p></li>
<li><p><strong>class_total_sizes</strong> (<em>Dictionary of total pixels for each class in user_accuracy</em>) – </p></li>
<li><p><strong>variance_tolerance</strong> (<em>Acceptable vairance between the sample accuary and the data accuracy with a certain sample size</em>) – </p></li>
<li><p><strong>allocate_type</strong> (<em>The allocation strategy to be used. Can be 'equal'</em><em>, </em><em>'prop'</em><em> or </em><em>'olofsson'.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A dictionary of classes and no. pixels per class.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.validation.build_class_dict">
<code class="sig-prename descclassname">pyeo.validation.</code><code class="sig-name descname">build_class_dict</code><span class="sig-paren">(</span><em class="sig-param">class_array</em>, <em class="sig-param">no_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.validation.build_class_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dict of coordinates of the following shape:
[class, coord].
WARNING: This will take up a LOT of memory!</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.validation.cal_total_sample_size">
<code class="sig-prename descclassname">pyeo.validation.</code><code class="sig-name descname">cal_total_sample_size</code><span class="sig-paren">(</span><em class="sig-param">desired_standard_error</em>, <em class="sig-param">user_accuracy</em>, <em class="sig-param">total_class_sizes</em>, <em class="sig-param">type='simple'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.validation.cal_total_sample_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the number of sample points for a map to get a specified standard error.
:param desired_standard_error:
:type desired_standard_error: The desired standard error (between 0 and 1)
:param user_accuracy:
:type user_accuracy: A dictionary of user accuracies from apriori knowledge
:param total_class_sizes:
:type total_class_sizes: The total number of pixels for each class
:param type:
:type type: whether to use the simple approximation or the full expession from Olofsson eq 13</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The total number of sample points to achieve the specified error</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.validation.calc_minimum_n">
<code class="sig-prename descclassname">pyeo.validation.</code><code class="sig-name descname">calc_minimum_n</code><span class="sig-paren">(</span><em class="sig-param">expected_accuracy</em>, <em class="sig-param">variance_tolerance</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.validation.calc_minimum_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rminimum number of points required to achieve the specified accuracy
:param expected_accuracy:
:type expected_accuracy: Between 0 and 1
:param variance_tolerance:</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.validation.count_pixel_classes">
<code class="sig-prename descclassname">pyeo.validation.</code><code class="sig-name descname">count_pixel_classes</code><span class="sig-paren">(</span><em class="sig-param">map_path</em>, <em class="sig-param">no_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.validation.count_pixel_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts pixels in a map. Returns a dictionary of pixels.
:param map_path:
:type map_path: Path to the map to count
:param no_data:
:type no_data: A value to ignore</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>A dictionary of class</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>count</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.validation.part_fixed_value_sampling">
<code class="sig-prename descclassname">pyeo.validation.</code><code class="sig-name descname">part_fixed_value_sampling</code><span class="sig-paren">(</span><em class="sig-param">pinned_sample_numbers</em>, <em class="sig-param">class_total_sizes</em>, <em class="sig-param">total_sample_size</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.validation.part_fixed_value_sampling" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pinned_sample_numbers</strong> – </p></li>
<li><p><strong>class_total_sizes</strong> – </p></li>
<li><p><strong>total_sample_size</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyeo.validation.produce_stratified_validation_points">
<code class="sig-prename descclassname">pyeo.validation.</code><code class="sig-name descname">produce_stratified_validation_points</code><span class="sig-paren">(</span><em class="sig-param">map_path</em>, <em class="sig-param">out_path</em>, <em class="sig-param">class_sample_counts</em>, <em class="sig-param">no_data=None</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">produce_csv=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.validation.produce_stratified_validation_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a set of stratified validation points from map_path</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.validation.save_point_list_to_shapefile">
<code class="sig-prename descclassname">pyeo.validation.</code><code class="sig-name descname">save_point_list_to_shapefile</code><span class="sig-paren">(</span><em class="sig-param">class_sample_point_dict</em>, <em class="sig-param">out_path</em>, <em class="sig-param">geotransform</em>, <em class="sig-param">projection_wkt</em>, <em class="sig-param">produce_csv=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.validation.save_point_list_to_shapefile" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves a list of points to a shapefile at out_path. Need the gt and projection of the raster.
GT is needed to move each point to the centre of the pixel. Can also produce a .csv file for CoolEarth</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.validation.save_validation_maifest">
<code class="sig-prename descclassname">pyeo.validation.</code><code class="sig-name descname">save_validation_maifest</code><span class="sig-paren">(</span><em class="sig-param">out_path</em>, <em class="sig-param">class_counts</em>, <em class="sig-param">sample_size</em>, <em class="sig-param">class_sample_counts</em>, <em class="sig-param">target_standard_error</em>, <em class="sig-param">user_accuracies</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.validation.save_validation_maifest" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a json file containing the parameters used to produce this validation set</p>
</dd></dl>

<dl class="function">
<dt id="pyeo.validation.stratified_random_sample">
<code class="sig-prename descclassname">pyeo.validation.</code><code class="sig-name descname">stratified_random_sample</code><span class="sig-paren">(</span><em class="sig-param">map_path</em>, <em class="sig-param">class_sample_count</em>, <em class="sig-param">no_data=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyeo.validation.stratified_random_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a stratified list of pixel coordinates. WARNING: high mem!</p>
</dd></dl>

</div>
<p>A small test suite is located in pyeo/tests/pyeo_tests.py; this is designed for use with py.test.
Some example applications and demos are in pyeo/apps; for an illustration of the use of the library,
pyeo/apps/change_detection/simple_s2_change_detection.py is recommended.</p>
</div>
<div class="section" id="module-pyeo.apps.change_detection.image_comparison">
<span id="applications"></span><h1>Applications<a class="headerlink" href="#module-pyeo.apps.change_detection.image_comparison" title="Permalink to this headline">¶</a></h1>
<div class="section" id="image-comparison">
<h2>image_comparison<a class="headerlink" href="#image-comparison" title="Permalink to this headline">¶</a></h2>
<p>An application for applying a pickled scikit-learn model to two contiguous raster images.</p>
<p>Example call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$image_comparison image_1.tif image_2.tif model.pkl class_map.tif
</pre></div>
</div>
</div>
<span class="target" id="module-pyeo.apps.change_detection.rolling_composite_s2_change_detection"></span><div class="section" id="rolling-composite-s2-change-detection">
<h2>rolling_composite_s2_change_detection<a class="headerlink" href="#rolling-composite-s2-change-detection" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>An app for providing continuous change detection. Runs the following algorithm</dt><dd><p>Step -1: Create initial composite with last date (stored in filename?)</p>
<p>Step 0: Load composite</p>
<p>Step 1: Download images from last date in composite until present last date</p>
<p>Step 2: Preprocess each image</p>
<p>Step 3: Generate cloud mask for each image</p>
</dd>
</dl>
<p>For each preprocessed image:</p>
<blockquote>
<div><p>Step 4: Build stack with composite</p>
<p>Step 5: Classify stack</p>
<p>Step 6: Update composite with last cloud-free pixel based on cloud mask</p>
<p>Step 7: Update last_date of composite</p>
</div></blockquote>
</div>
<span class="target" id="module-pyeo.apps.change_detection.simple_s2_change_detection"></span><div class="section" id="simple-s2-change-detection">
<h2>simple_s2_change_detection<a class="headerlink" href="#simple-s2-change-detection" title="Permalink to this headline">¶</a></h2>
<p>A change detection script that downloads, stacks and classifies a set of 10m sentinel 2 images.</p>
<p>When run, this script will download every S2 image in the aoi (defined by the geojson at aoi_path) between the two
dates that meets the specified cloud cover range. It will use the sen2cor distribution specified in the .ini file
to atmospherically correct the data to L2A, merge each set of 10m bands into a single geotiff, stack the images
into pairs based on the algorithm in create_new_stacks and classify those images using a scikit-learn model</p>
<p>To use this script, fill out the [sent_2], [forest_sentinel] and [sen2cor] sections of the configuration file
change_detection.ini, then run</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ python pyeo/apps/change_detection/simple_s2_change_detection.py --conf /path/to/change_detection.ini
</pre></div>
</div>
<p>Produces two directories of un-mosaiced imagery; one of classified images and one of class probabilites</p>
</div>
<span class="target" id="module-pyeo.apps.masking.filter_by_class_map"></span><div class="section" id="filter-by-class-map">
<h2>filter_by_class_map<a class="headerlink" href="#filter-by-class-map" title="Permalink to this headline">¶</a></h2>
<p>Filters every pixel in input_image that is not one of filter_classes.</p>
<p>Usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ filter_by_class_map my_image.tif my_class_map.tif my_output_image.tif useful_class_1 useful_class_2
</pre></div>
</div>
<p>This will create an image, my_output_image.tif, that contains only the pixels from my_image.tif
that are labelled as useful_class_1 and useful_class_2 in my_class_map.tif</p>
</div>
<span class="target" id="module-pyeo.apps.model_creation.create_model_from_region"></span></div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">Pyeo</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, John Roberts.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>