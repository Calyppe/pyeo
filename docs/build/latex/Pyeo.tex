%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Pyeo Documentation}
\date{Aug 06, 2019}
\release{}
\author{John Roberts}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\chapter{Introduction}
\label{\detokenize{index:introduction}}
Python For Earth Observation is a collection of functions for downloading, manipulating, combining and classifying
geospatial raster and vector data. It is intended to require a minimum of dependencies - most functions only require
the basic GDAL/OGR/OSR stack.


\chapter{Installation}
\label{\detokenize{index:installation}}
With Git and Miniconda or Anaconda installed, \sphinxcode{\sphinxupquote{cd}} to an install location then run the following lines

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone https://github.com/clcr/pyeo.git
\PYG{n+nb}{cd} pyeo
conda env create \PYGZhy{}\PYGZhy{}file environment.yml \PYGZhy{}\PYGZhy{}name pyeo\PYGZus{}env
conda activate pyeo\PYGZus{}env
\end{sphinxVerbatim}


\chapter{Including Pyeo in your own code}
\label{\detokenize{index:including-pyeo-in-your-own-code}}
Include the following lines at the start of your Python scripts:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/path/to/pyeo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{pyeo.core} \PYG{k+kn}{as} \PYG{n+nn}{pyeo}
\end{sphinxVerbatim}

You may see a warning about scikit versions; this is normal.


\chapter{Filenaming, assumptions and structure}
\label{\detokenize{index:filenaming-assumptions-and-structure}}
Pyeo is divided into high-level and low-level fucntions.


\chapter{Function reference}
\label{\detokenize{index:module-pyeo.classification}}\label{\detokenize{index:function-reference}}\index{pyeo.classification (module)@\spxentry{pyeo.classification}\spxextra{module}}

\section{pyeo.classification}
\label{\detokenize{index:pyeo-classification}}
Contains every function to do with map classification. This includes model creation, map classification and processes
for array manipulation into scikit-learn compatible forms.
\index{autochunk() (in module pyeo.classification)@\spxentry{autochunk()}\spxextra{in module pyeo.classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.classification.autochunk}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.classification.}}\sphinxbfcode{\sphinxupquote{autochunk}}}{\emph{dataset}, \emph{mem\_limit=None}}{}
Calculates the number of chunks to break a dataset into without a memory error.
We want to break the dataset into as few chunks as possible without going over mem\_limit.
mem\_limit defaults to total amount of RAM available on machine if not specified

\end{fulllineitems}

\index{change\_from\_composite() (in module pyeo.classification)@\spxentry{change\_from\_composite()}\spxextra{in module pyeo.classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.classification.change_from_composite}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.classification.}}\sphinxbfcode{\sphinxupquote{change\_from\_composite}}}{\emph{image\_path}, \emph{composite\_path}, \emph{model\_path}, \emph{class\_out\_path}, \emph{prob\_out\_path}}{}
Generates a change map comparing an image with a composite

\end{fulllineitems}

\index{classify\_directory() (in module pyeo.classification)@\spxentry{classify\_directory()}\spxextra{in module pyeo.classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.classification.classify_directory}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.classification.}}\sphinxbfcode{\sphinxupquote{classify\_directory}}}{\emph{in\_dir}, \emph{model\_path}, \emph{class\_out\_dir}, \emph{prob\_out\_dir}, \emph{apply\_mask=False}, \emph{out\_type='GTiff'}, \emph{num\_chunks=None}}{}
Classifies every .tif in in\_dir using model at model\_path. Outputs are saved
in class\_out\_dir and prob\_out\_dir, named {[}input\_name{]}\_class and \_prob, respectively.

\end{fulllineitems}

\index{classify\_image() (in module pyeo.classification)@\spxentry{classify\_image()}\spxextra{in module pyeo.classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.classification.classify_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.classification.}}\sphinxbfcode{\sphinxupquote{classify\_image}}}{\emph{image\_path}, \emph{model\_path}, \emph{class\_out\_path}, \emph{prob\_out\_path=None}, \emph{apply\_mask=False}, \emph{out\_type='GTiff'}, \emph{num\_chunks=10}, \emph{nodata=0}, \emph{skip\_existing=False}}{}
Classifies change between two stacked images.
Images need to be chunked, otherwise they cause a memory error (\textasciitilde{}16GB of data with a \textasciitilde{}15GB machine)
TODO: This has gotten very hairy; rewrite when you update this to take generic models

\end{fulllineitems}

\index{create\_model\_for\_region() (in module pyeo.classification)@\spxentry{create\_model\_for\_region()}\spxextra{in module pyeo.classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.classification.create_model_for_region}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.classification.}}\sphinxbfcode{\sphinxupquote{create\_model\_for\_region}}}{\emph{path\_to\_region}, \emph{model\_out}, \emph{scores\_out}, \emph{attribute='CODE'}}{}
Creates a model based on training data for files in a given region

\end{fulllineitems}

\index{create\_trained\_model() (in module pyeo.classification)@\spxentry{create\_trained\_model()}\spxextra{in module pyeo.classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.classification.create_trained_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.classification.}}\sphinxbfcode{\sphinxupquote{create\_trained\_model}}}{\emph{training\_image\_file\_paths}, \emph{cross\_val\_repeats=5}, \emph{attribute='CODE'}}{}
Returns a trained random forest model from the training data. This
assumes that image and model are in the same directory, with a shapefile.
Give training\_image\_path a path to a list of .tif files. See spec in the R drive for data structure.
At present, the model is an ExtraTreesClassifier arrived at by tpot; see tpot\_classifier\_kenya -\textgreater{} tpot 1)

\end{fulllineitems}

\index{get\_training\_data() (in module pyeo.classification)@\spxentry{get\_training\_data()}\spxextra{in module pyeo.classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.classification.get_training_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.classification.}}\sphinxbfcode{\sphinxupquote{get\_training\_data}}}{\emph{image\_path}, \emph{shape\_path}, \emph{attribute='CODE'}, \emph{shape\_projection\_id=4326}}{}
Given an image and a shapefile with categories, return x and y suitable
for feeding into random\_forest.fit.
Note: THIS WILL FAIL IF YOU HAVE ANY CLASSES NUMBERED ‘0’.

\end{fulllineitems}

\index{raster\_reclass\_binary() (in module pyeo.classification)@\spxentry{raster\_reclass\_binary()}\spxextra{in module pyeo.classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.classification.raster_reclass_binary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.classification.}}\sphinxbfcode{\sphinxupquote{raster\_reclass\_binary}}}{\emph{img\_path}, \emph{rcl\_value}, \emph{outFn}, \emph{outFmt='GTiff'}, \emph{write\_out=True}}{}
Takes a raster and reclassifies the values
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{img\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to 1 band input  raster.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rcl\_value}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Integer indication the value that should be reclassified to 1. All other values will be 0.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outFn}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Output file name.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outFmt}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Output format. Set to GTiff by default. Other GDAL options available.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{write\_out}} \textendash{} Boolean. Set to True by default. Will write raster to disk. If False, only an array is returned

\end{itemize}

\item[{Returns}] \leavevmode
Reclassifies numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{reshape\_ml\_out\_to\_raster() (in module pyeo.classification)@\spxentry{reshape\_ml\_out\_to\_raster()}\spxextra{in module pyeo.classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.classification.reshape_ml_out_to_raster}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.classification.}}\sphinxbfcode{\sphinxupquote{reshape\_ml\_out\_to\_raster}}}{\emph{classes}, \emph{width}, \emph{height}}{}
Reshapes an output {[}x*y{]} to gdal order {[}y, x{]}

\end{fulllineitems}

\index{reshape\_prob\_out\_to\_raster() (in module pyeo.classification)@\spxentry{reshape\_prob\_out\_to\_raster()}\spxextra{in module pyeo.classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.classification.reshape_prob_out_to_raster}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.classification.}}\sphinxbfcode{\sphinxupquote{reshape\_prob\_out\_to\_raster}}}{\emph{probs}, \emph{width}, \emph{height}}{}
reshapes an output of shape {[}x*y, classes{]} to gdal order {[}classes, y, x{]}

\end{fulllineitems}

\index{reshape\_raster\_for\_ml() (in module pyeo.classification)@\spxentry{reshape\_raster\_for\_ml()}\spxextra{in module pyeo.classification}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.classification.reshape_raster_for_ml}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.classification.}}\sphinxbfcode{\sphinxupquote{reshape\_raster\_for\_ml}}}{\emph{image\_array}}{}
Reshapes an array from gdal order {[}band, y, x{]} to scikit order {[}x*y, band{]}

\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-pyeo.array_utilities}}\index{pyeo.array\_utilities (module)@\spxentry{pyeo.array\_utilities}\spxextra{module}}
Contains routines for manipulating arrays.
\index{project\_array() (in module pyeo.array\_utilities)@\spxentry{project\_array()}\spxextra{in module pyeo.array\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.array_utilities.project_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.array\_utilities.}}\sphinxbfcode{\sphinxupquote{project\_array}}}{\emph{array\_in}, \emph{depth}, \emph{axis}}{}
Returns a new array with an extra dimension. Data is projected along that dimension to depth.

\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-pyeo.coordinate_manipulation}}\index{pyeo.coordinate\_manipulation (module)@\spxentry{pyeo.coordinate\_manipulation}\spxextra{module}}

\section{pyeo.coordinate\_manipulation}
\label{\detokenize{index:pyeo-coordinate-manipulation}}
Contains a set of functions for transforming spatial coorinates between projections and pixel indicies.
\index{align\_bounds\_to\_whole\_number() (in module pyeo.coordinate\_manipulation)@\spxentry{align\_bounds\_to\_whole\_number()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.align_bounds_to_whole_number}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{align\_bounds\_to\_whole\_number}}}{\emph{bounding\_box}}{}
Shifts bounding\_box polygon so that its size becomes a whole number

\end{fulllineitems}

\index{check\_overlap() (in module pyeo.coordinate\_manipulation)@\spxentry{check\_overlap()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.check_overlap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{check\_overlap}}}{\emph{raster}, \emph{aoi}}{}
Checks that a raster and an AOI overlap

\end{fulllineitems}

\index{floor\_to\_resolution() (in module pyeo.coordinate\_manipulation)@\spxentry{floor\_to\_resolution()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.floor_to_resolution}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{floor\_to\_resolution}}}{\emph{input}, \emph{resolution}}{}
Returns input rounded DOWN to the nearest multiple of resolution.

\end{fulllineitems}

\index{get\_aoi\_bounds() (in module pyeo.coordinate\_manipulation)@\spxentry{get\_aoi\_bounds()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.get_aoi_bounds}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_aoi\_bounds}}}{\emph{aoi}}{}
Returns a wkbPolygon geometry with the bounding rectangle of a single-polygon shapefile

\end{fulllineitems}

\index{get\_aoi\_intersection() (in module pyeo.coordinate\_manipulation)@\spxentry{get\_aoi\_intersection()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.get_aoi_intersection}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_aoi\_intersection}}}{\emph{raster}, \emph{aoi}}{}
Returns a wkbPolygon geometry with the intersection of a raster and an aoi

\end{fulllineitems}

\index{get\_aoi\_size() (in module pyeo.coordinate\_manipulation)@\spxentry{get\_aoi\_size()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.get_aoi_size}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_aoi\_size}}}{\emph{aoi}}{}
Returns the width and height of the bounding box of an aoi. No test

\end{fulllineitems}

\index{get\_combined\_polygon() (in module pyeo.coordinate\_manipulation)@\spxentry{get\_combined\_polygon()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.get_combined_polygon}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_combined\_polygon}}}{\emph{rasters}, \emph{geometry\_mode='intersect'}}{}
Calculates the overall polygon boundary for multiple rasters

\end{fulllineitems}

\index{get\_local\_top\_left() (in module pyeo.coordinate\_manipulation)@\spxentry{get\_local\_top\_left()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.get_local_top_left}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_local\_top\_left}}}{\emph{raster1}, \emph{raster2}}{}
Gets the top-left corner of raster1 in the array of raster 2; WRITE A TEST FOR THIS

\end{fulllineitems}

\index{get\_poly\_bounding\_rect() (in module pyeo.coordinate\_manipulation)@\spxentry{get\_poly\_bounding\_rect()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.get_poly_bounding_rect}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_poly\_bounding\_rect}}}{\emph{poly}}{}
Returns a polygon of the bounding rectangle of input polygon. Can probably be combined with
get\_aoi\_bounds.

\end{fulllineitems}

\index{get\_poly\_intersection() (in module pyeo.coordinate\_manipulation)@\spxentry{get\_poly\_intersection()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.get_poly_intersection}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_poly\_intersection}}}{\emph{poly1}, \emph{poly2}}{}
Trivial function returns the intersection between two polygons. No test.

\end{fulllineitems}

\index{get\_poly\_size() (in module pyeo.coordinate\_manipulation)@\spxentry{get\_poly\_size()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.get_poly_size}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_poly\_size}}}{\emph{poly}}{}
Returns the width and height of a bounding box of a polygon. No test

\end{fulllineitems}

\index{get\_raster\_bounds() (in module pyeo.coordinate\_manipulation)@\spxentry{get\_raster\_bounds()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.get_raster_bounds}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_raster\_bounds}}}{\emph{raster}}{}
Returns a wkbPolygon geometry with the bounding rectangle of a raster calculated from its geotransform

\end{fulllineitems}

\index{get\_raster\_intersection() (in module pyeo.coordinate\_manipulation)@\spxentry{get\_raster\_intersection()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.get_raster_intersection}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_raster\_intersection}}}{\emph{raster1}, \emph{raster2}}{}
Returns a wkbPolygon geometry with the intersection of two raster bounding boxes

\end{fulllineitems}

\index{get\_raster\_size() (in module pyeo.coordinate\_manipulation)@\spxentry{get\_raster\_size()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.get_raster_size}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_raster\_size}}}{\emph{raster}}{}
Return the height and width of a raster

\end{fulllineitems}

\index{multiple\_intersection() (in module pyeo.coordinate\_manipulation)@\spxentry{multiple\_intersection()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.multiple_intersection}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{multiple\_intersection}}}{\emph{polygons}}{}
Takes a list of polygons and returns a geometry representing the intersection of all of them

\end{fulllineitems}

\index{multiple\_union() (in module pyeo.coordinate\_manipulation)@\spxentry{multiple\_union()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.multiple_union}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{multiple\_union}}}{\emph{polygons}}{}
Takes a list of polygons and returns a geometry representing the union of all of them

\end{fulllineitems}

\index{pixel\_bounds\_from\_polygon() (in module pyeo.coordinate\_manipulation)@\spxentry{pixel\_bounds\_from\_polygon()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.pixel_bounds_from_polygon}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{pixel\_bounds\_from\_polygon}}}{\emph{raster}, \emph{polygon}}{}
Returns the pixel coordinates of the bounds of the
intersection between polygon and raster

\end{fulllineitems}

\index{pixel\_to\_point\_coordinates() (in module pyeo.coordinate\_manipulation)@\spxentry{pixel\_to\_point\_coordinates()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.pixel_to_point_coordinates}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{pixel\_to\_point\_coordinates}}}{\emph{pixel}, \emph{GT}}{}
Converts a pixel to it’s coords implied by geotransform GT.
NOTE: This will not give the pixels precise location on the earth’s surface;
you’ll also need to make sure tha this is in the correct projection

\end{fulllineitems}

\index{point\_to\_pixel\_coordinates() (in module pyeo.coordinate\_manipulation)@\spxentry{point\_to\_pixel\_coordinates()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.point_to_pixel_coordinates}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{point\_to\_pixel\_coordinates}}}{\emph{raster}, \emph{point}, \emph{oob\_fail=False}}{}
Returns a tuple (x\_pixel, y\_pixel) in a georaster raster corresponding to the point.
Point can be an ogr point object, a wkt string or an x, y tuple or list. Assumes north-up non rotated.
Will floor() decimal output

\end{fulllineitems}

\index{reproject\_geotransform() (in module pyeo.coordinate\_manipulation)@\spxentry{reproject\_geotransform()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.reproject_geotransform}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{reproject\_geotransform}}}{\emph{in\_gt}, \emph{old\_proj\_wkt}, \emph{new\_proj\_wkt}}{}
Reprojects a geotransform into a new projection.

\end{fulllineitems}

\index{write\_geometry() (in module pyeo.coordinate\_manipulation)@\spxentry{write\_geometry()}\spxextra{in module pyeo.coordinate\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.coordinate_manipulation.write_geometry}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.coordinate\_manipulation.}}\sphinxbfcode{\sphinxupquote{write\_geometry}}}{\emph{geometry}, \emph{out\_path}, \emph{srs\_id=4326}}{}
Saves a polygon to a shapefile

\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-pyeo.filesystem_utilities}}\index{pyeo.filesystem\_utilities (module)@\spxentry{pyeo.filesystem\_utilities}\spxextra{module}}

\section{pyeo.filesystem\_utilities}
\label{\detokenize{index:pyeo-filesystem-utilities}}
Contains functions for sorting, creating and comparing images as part of the filesystem. Includes any function
that works on a generic pyeo timestamp and sentinel 2 functions.
\index{check\_for\_invalid\_l1\_data() (in module pyeo.filesystem\_utilities)@\spxentry{check\_for\_invalid\_l1\_data()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.check_for_invalid_l1_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{check\_for\_invalid\_l1\_data}}}{\emph{l1\_SAFE\_file}}{}
Checks the existance of the specified resolution of imagery. Returns True with a warning if passed
an invalid SAFE directory; this will prevent disconnected files from being deleted.
Retuns 1 if imagery is valid, 0 if not and 2 if not a safe-file

\end{fulllineitems}

\index{check\_for\_invalid\_l2\_data() (in module pyeo.filesystem\_utilities)@\spxentry{check\_for\_invalid\_l2\_data()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.check_for_invalid_l2_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{check\_for\_invalid\_l2\_data}}}{\emph{l2\_SAFE\_file}, \emph{resolution='10m'}}{}
Checks the existance of the specified resolution of imagery. Returns a True-value with a warning if passed
an invalid SAFE directory; this will prevent disconnected files from being deleted.
Retuns 1 if imagery is valid, 0 if not and 2 if not a safe-file

\end{fulllineitems}

\index{clean\_aoi() (in module pyeo.filesystem\_utilities)@\spxentry{clean\_aoi()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.clean_aoi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{clean\_aoi}}}{\emph{aoi\_dir}, \emph{images\_to\_keep=4}, \emph{warning=True}}{}
Removes all but the last images\_to\_keep newest images in the L1, L2, merged, stacked and
composite directories. Will not affect the output folder.

\end{fulllineitems}

\index{clean\_l2\_data() (in module pyeo.filesystem\_utilities)@\spxentry{clean\_l2\_data()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.clean_l2_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{clean\_l2\_data}}}{\emph{l2\_SAFE\_file}, \emph{resolution='10m'}, \emph{warning=True}}{}
Removes any directories that don’t have band 2, 3, 4 or 8 in the specified resolution folder
If warning=True, prompts first.

\end{fulllineitems}

\index{clean\_l2\_dir() (in module pyeo.filesystem\_utilities)@\spxentry{clean\_l2\_dir()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.clean_l2_dir}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{clean\_l2\_dir}}}{\emph{l2\_dir}, \emph{resolution='10m'}, \emph{warning=True}}{}
Calls clean\_l2\_data on every SAFE file in l2\_dir

\end{fulllineitems}

\index{create\_file\_structure() (in module pyeo.filesystem\_utilities)@\spxentry{create\_file\_structure()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.create_file_structure}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{create\_file\_structure}}}{\emph{root}}{}
Creates the file structure if it doesn’t exist already

\end{fulllineitems}

\index{get\_change\_detection\_dates() (in module pyeo.filesystem\_utilities)@\spxentry{get\_change\_detection\_dates()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_change_detection_dates}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_change\_detection\_dates}}}{\emph{image\_name}}{}
Takes the source filepath and extracts the before\_date and after\_date dates from in, in that order.

\end{fulllineitems}

\index{get\_image\_acquisition\_time() (in module pyeo.filesystem\_utilities)@\spxentry{get\_image\_acquisition\_time()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_image_acquisition_time}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_image\_acquisition\_time}}}{\emph{image\_name}}{}
Gets the datetime object from a .safe filename of a planet image. No test. Returns None if no timestamp present

\end{fulllineitems}

\index{get\_l1\_safe\_file() (in module pyeo.filesystem\_utilities)@\spxentry{get\_l1\_safe\_file()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_l1_safe_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_l1\_safe\_file}}}{\emph{image\_name}, \emph{l1\_dir}}{}
Returns the path to the L1 .SAFE directory of image. Gets from granule and timestamp. image\_name can be a path or
a filename

\end{fulllineitems}

\index{get\_l2\_safe\_file() (in module pyeo.filesystem\_utilities)@\spxentry{get\_l2\_safe\_file()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_l2_safe_file}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_l2\_safe\_file}}}{\emph{image\_name}, \emph{l2\_dir}}{}
Returns the path to the L2 .SAFE directory of image. Gets from granule and timestamp. image\_name can be a path or
a filename

\end{fulllineitems}

\index{get\_mask\_path() (in module pyeo.filesystem\_utilities)@\spxentry{get\_mask\_path()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_mask_path}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_mask\_path}}}{\emph{image\_path}}{}
A gdal mask is an image with the same name as the image it’s masking, but with a .msk extension

\end{fulllineitems}

\index{get\_preceding\_image\_path() (in module pyeo.filesystem\_utilities)@\spxentry{get\_preceding\_image\_path()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_preceding_image_path}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_preceding\_image\_path}}}{\emph{target\_image\_name}, \emph{search\_dir}}{}
Gets the path to the image in search\_dir preceding the image called image\_name

\end{fulllineitems}

\index{get\_pyeo\_timestamp() (in module pyeo.filesystem\_utilities)@\spxentry{get\_pyeo\_timestamp()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_pyeo_timestamp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_pyeo\_timestamp}}}{\emph{image\_name}}{}
Returns a list of all timestamps in a Pyeo image.

\end{fulllineitems}

\index{get\_related\_images() (in module pyeo.filesystem\_utilities)@\spxentry{get\_related\_images()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_related_images}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_related\_images}}}{\emph{target\_image\_name}, \emph{project\_dir}}{}
Gets the paths of all images related to that one in a project, by timestamp

\end{fulllineitems}

\index{get\_sen\_2\_granule\_id() (in module pyeo.filesystem\_utilities)@\spxentry{get\_sen\_2\_granule\_id()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_sen_2_granule_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_sen\_2\_granule\_id}}}{\emph{safe\_dir}}{}
Returns the unique ID of a Sentinel 2 granule from a SAFE directory path

\end{fulllineitems}

\index{get\_sen\_2\_image\_orbit() (in module pyeo.filesystem\_utilities)@\spxentry{get\_sen\_2\_image\_orbit()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_sen_2_image_orbit}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_sen\_2\_image\_orbit}}}{\emph{image\_name}}{}
Returns the relative orbit number of a Sentinel 2 image

\end{fulllineitems}

\index{get\_sen\_2\_image\_tile() (in module pyeo.filesystem\_utilities)@\spxentry{get\_sen\_2\_image\_tile()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_sen_2_image_tile}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_sen\_2\_image\_tile}}}{\emph{image\_name}}{}
Returns the tile number of a Sentinel 2 image or path

\end{fulllineitems}

\index{get\_sen\_2\_image\_timestamp() (in module pyeo.filesystem\_utilities)@\spxentry{get\_sen\_2\_image\_timestamp()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_sen_2_image_timestamp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_sen\_2\_image\_timestamp}}}{\emph{image\_name}}{}
Returns the timestamps part of a Sentinel 2 image

\end{fulllineitems}

\index{get\_sen\_2\_tiles() (in module pyeo.filesystem\_utilities)@\spxentry{get\_sen\_2\_tiles()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.get_sen_2_tiles}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{get\_sen\_2\_tiles}}}{\emph{image\_dir}}{}
gets the list of tiles present in the directory

\end{fulllineitems}

\index{init\_log() (in module pyeo.filesystem\_utilities)@\spxentry{init\_log()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.init_log}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{init\_log}}}{\emph{log\_path}}{}
Sets up the log format and log handlers; one for stdout and to write to a file, ‘log\_path’.
Returns the log for the calling script

\end{fulllineitems}

\index{is\_tif() (in module pyeo.filesystem\_utilities)@\spxentry{is\_tif()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.is_tif}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{is\_tif}}}{\emph{image\_string}}{}
Returns True if image ends with .tif

\end{fulllineitems}

\index{sort\_by\_timestamp() (in module pyeo.filesystem\_utilities)@\spxentry{sort\_by\_timestamp()}\spxextra{in module pyeo.filesystem\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.filesystem_utilities.sort_by_timestamp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.filesystem\_utilities.}}\sphinxbfcode{\sphinxupquote{sort\_by\_timestamp}}}{\emph{strings}, \emph{recent\_first=True}}{}
Takes a list of strings that contain sen2 timestamps and returns them sorted, most recent first. Does not
guarantee ordering of strings with the same timestamp. Removes any string that does not contain a timestamp

\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-pyeo.queries_and_downloads}}\index{pyeo.queries\_and\_downloads (module)@\spxentry{pyeo.queries\_and\_downloads}\spxextra{module}}

\section{pyeo.queries\_and\_downloads}
\label{\detokenize{index:pyeo-queries-and-downloads}}
Functions for querying, filtering and downloading data.
\index{activate\_and\_dl\_planet\_item() (in module pyeo.queries\_and\_downloads)@\spxentry{activate\_and\_dl\_planet\_item()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.activate_and_dl_planet_item}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{activate\_and\_dl\_planet\_item}}}{\emph{session}, \emph{item}, \emph{asset\_type}, \emph{file\_path}}{}
Activates and downloads a single planet item

\end{fulllineitems}

\index{build\_search\_request() (in module pyeo.queries\_and\_downloads)@\spxentry{build\_search\_request()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.build_search_request}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{build\_search\_request}}}{\emph{aoi}, \emph{start\_date}, \emph{end\_date}, \emph{item\_type}, \emph{search\_name}}{}
Builds a search request for the planet API

\end{fulllineitems}

\index{do\_quick\_search() (in module pyeo.queries\_and\_downloads)@\spxentry{do\_quick\_search()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.do_quick_search}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{do\_quick\_search}}}{\emph{session}, \emph{search\_request}}{}
Tries the quick search; returns a dict of features

\end{fulllineitems}

\index{do\_saved\_search() (in module pyeo.queries\_and\_downloads)@\spxentry{do\_saved\_search()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.do_saved_search}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{do\_saved\_search}}}{\emph{session}, \emph{search\_request}}{}
Does a saved search; this doesn’t seem to work yet.

\end{fulllineitems}

\index{download\_from\_aws\_with\_rollback() (in module pyeo.queries\_and\_downloads)@\spxentry{download\_from\_aws\_with\_rollback()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.download_from_aws_with_rollback}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{download\_from\_aws\_with\_rollback}}}{\emph{product\_id}, \emph{folder}, \emph{uuid}, \emph{user}, \emph{passwd}}{}
Attempts to download product from AWS using product\_id; if not found, rolls back to Scihub using uuid

\end{fulllineitems}

\index{download\_from\_google\_cloud() (in module pyeo.queries\_and\_downloads)@\spxentry{download\_from\_google\_cloud()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.download_from_google_cloud}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{download\_from\_google\_cloud}}}{\emph{product\_ids}, \emph{out\_folder}, \emph{redownload=False}}{}
Passed a list of S2 product ids , downloads them into out\_for

\end{fulllineitems}

\index{download\_from\_scihub() (in module pyeo.queries\_and\_downloads)@\spxentry{download\_from\_scihub()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.download_from_scihub}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{download\_from\_scihub}}}{\emph{product\_uuid}, \emph{out\_folder}, \emph{user}, \emph{passwd}}{}
Downloads and unzips product\_uuid from scihub

\end{fulllineitems}

\index{download\_planet\_image\_on\_day() (in module pyeo.queries\_and\_downloads)@\spxentry{download\_planet\_image\_on\_day()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.download_planet_image_on_day}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{download\_planet\_image\_on\_day}}}{\emph{aoi\_path}, \emph{date}, \emph{out\_path}, \emph{api\_key}, \emph{item\_type='PSScene4Band'}, \emph{search\_name='auto'}, \emph{asset\_type='analytic'}, \emph{threads=5}}{}
Queries and downloads all images on the date in the aoi given

\end{fulllineitems}

\index{download\_s2\_data() (in module pyeo.queries\_and\_downloads)@\spxentry{download\_s2\_data()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.download_s2_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{download\_s2\_data}}}{\emph{new\_data}, \emph{l1\_dir}, \emph{l2\_dir}, \emph{source='scihub'}, \emph{user=None}, \emph{passwd=None}, \emph{try\_scihub\_on\_fail=False}}{}
Downloads S2 imagery from AWS, google\_cloud or scihub. new\_data is a dict from Sentinel\_2.

\end{fulllineitems}

\index{filter\_non\_matching\_s2\_data() (in module pyeo.queries\_and\_downloads)@\spxentry{filter\_non\_matching\_s2\_data()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.filter_non_matching_s2_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{filter\_non\_matching\_s2\_data}}}{\emph{query\_output}}{}
Removes any L2/L1 product that does not have a corresponding L1/L2 data

\end{fulllineitems}

\index{get\_granule\_identifiers() (in module pyeo.queries\_and\_downloads)@\spxentry{get\_granule\_identifiers()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.get_granule_identifiers}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{get\_granule\_identifiers}}}{\emph{safe\_product\_id}}{}
Returns the parts of a S2 name that uniquely identify that granulate at a moment in time

\end{fulllineitems}

\index{get\_paginated\_items() (in module pyeo.queries\_and\_downloads)@\spxentry{get\_paginated\_items()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.get_paginated_items}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{get\_paginated\_items}}}{\emph{session}, \emph{search\_id}}{}
Let’s leave this out for now.

\end{fulllineitems}

\index{get\_planet\_product\_path() (in module pyeo.queries\_and\_downloads)@\spxentry{get\_planet\_product\_path()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.get_planet_product_path}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{get\_planet\_product\_path}}}{\emph{planet\_dir}, \emph{product}}{}
Returns the path to a Planet product within a Planet directory

\end{fulllineitems}

\index{load\_api\_key() (in module pyeo.queries\_and\_downloads)@\spxentry{load\_api\_key()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.load_api_key}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{load\_api\_key}}}{\emph{path\_to\_api}}{}
Returns an API key from a single-line text file containing that API

\end{fulllineitems}

\index{planet\_query() (in module pyeo.queries\_and\_downloads)@\spxentry{planet\_query()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.planet_query}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{planet\_query}}}{\emph{aoi\_path}, \emph{start\_date}, \emph{end\_date}, \emph{out\_path}, \emph{api\_key}, \emph{item\_type='PSScene4Band'}, \emph{search\_name='auto'}, \emph{asset\_type='analytic'}, \emph{threads=5}}{}
Downloads data from Planetlabs for a given time period in the given AOI
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{aoi}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Filepath of a single-polygon geojson containing the aoi

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{start\_date}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the inclusive start of the time window in UTC format

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{end\_date}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the inclusive end of the time window in UTC format

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{out\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{filepath-like object}}) \textendash{} A path to the output folder
Any identically-named imagery will be overwritten

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{item\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Image type to download (see Planet API docs)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{search\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} A name to refer to the search (required for large searches)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{asset\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Planet asset type to download (see Planet API docs)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{threads}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of downloads to perform concurrently

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

IMPORTANT: Will not run for searches returning greater than 250 items.

\end{fulllineitems}

\index{read\_aoi() (in module pyeo.queries\_and\_downloads)@\spxentry{read\_aoi()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.read_aoi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{read\_aoi}}}{\emph{aoi\_path}}{}
Opens the geojson file for the aoi. If FeatureCollection, return the first feature.

\end{fulllineitems}

\index{sent2\_query() (in module pyeo.queries\_and\_downloads)@\spxentry{sent2\_query()}\spxextra{in module pyeo.queries\_and\_downloads}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.queries_and_downloads.sent2_query}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.queries\_and\_downloads.}}\sphinxbfcode{\sphinxupquote{sent2\_query}}}{\emph{user}, \emph{passwd}, \emph{geojsonfile}, \emph{start\_date}, \emph{end\_date}, \emph{cloud=50}}{}
From Geospatial Learn by Ciaran Robb, embedded here for portability.

Produces a dict of sentinel-2 IDs and
\subsubsection*{Notes}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{user}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} username for esa hub

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{passwd}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} password for hub

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{geojsonfile}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} AOI polygon of interest in EPSG 4326

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{start\_date}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} date of beginning of search

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{end\_date}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} date of end of search

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cloud}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} include a cloud filter in the search

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{product}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Product type for Sentinel 2. Valid values are S2MSI1C and S2MS2Ap

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-pyeo.raster_manipulation}}\index{pyeo.raster\_manipulation (module)@\spxentry{pyeo.raster\_manipulation}\spxextra{module}}

\section{pyeo.raster\_manipulation}
\label{\detokenize{index:pyeo-raster-manipulation}}
Functions for working with raster data.
\index{apply\_array\_image\_mask() (in module pyeo.raster\_manipulation)@\spxentry{apply\_array\_image\_mask()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.apply_array_image_mask}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{apply\_array\_image\_mask}}}{\emph{array}, \emph{mask}, \emph{fill\_value=0}}{}
Applies a mask of (y,x) to an image array of (bands, y, x). Replaces any masked pixels with fill\_value
Mask is an a 2 dimensional array of 1 ( unmasked) and 0 (masked)

\end{fulllineitems}

\index{apply\_fmask() (in module pyeo.raster\_manipulation)@\spxentry{apply\_fmask()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.apply_fmask}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{apply\_fmask}}}{\emph{in\_safe\_dir}, \emph{out\_file}, \emph{fmask\_command='fmask\_sentinel2Stacked.py'}}{}
Calls fmask to create a new mask for L1 data

\end{fulllineitems}

\index{apply\_sen2cor() (in module pyeo.raster\_manipulation)@\spxentry{apply\_sen2cor()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.apply_sen2cor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{apply\_sen2cor}}}{\emph{image\_path}, \emph{sen2cor\_path}, \emph{delete\_unprocessed\_image=False}}{}
Applies sen2cor to the SAFE file at image\_path. Returns the path to the new product.

\end{fulllineitems}

\index{atmospheric\_correction() (in module pyeo.raster\_manipulation)@\spxentry{atmospheric\_correction()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.atmospheric_correction}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{atmospheric\_correction}}}{\emph{in\_directory}, \emph{out\_directory}, \emph{sen2cor\_path}, \emph{delete\_unprocessed\_image=False}}{}
Applies Sen2cor cloud correction to level 1C images

\end{fulllineitems}

\index{buffer\_mask\_in\_place() (in module pyeo.raster\_manipulation)@\spxentry{buffer\_mask\_in\_place()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.buffer_mask_in_place}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{buffer\_mask\_in\_place}}}{\emph{mask\_path}, \emph{buffer\_size}}{}
Expands a mask in-place, overwriting the previous mask

\end{fulllineitems}

\index{clip\_raster() (in module pyeo.raster\_manipulation)@\spxentry{clip\_raster()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.clip_raster}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{clip\_raster}}}{\emph{raster\_path}, \emph{aoi\_path}, \emph{out\_path}, \emph{srs\_id=4326}}{}
Clips a raster at raster\_path to a shapefile given by aoi\_path. Assumes a shapefile only has one polygon.
Will np.floor() when converting from geo to pixel units and np.absolute() y resolution form geotransform.

\end{fulllineitems}

\index{combine\_masks() (in module pyeo.raster\_manipulation)@\spxentry{combine\_masks()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.combine_masks}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{combine\_masks}}}{\emph{mask\_paths}, \emph{out\_path}, \emph{combination\_func='and'}, \emph{geometry\_func='intersect'}}{}
ORs or ANDs several masks. Gets metadata from top mask. Assumes that masks are a
Python true or false. Also assumes that all masks are the same projection for now.

\end{fulllineitems}

\index{composite\_directory() (in module pyeo.raster\_manipulation)@\spxentry{composite\_directory()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.composite_directory}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{composite\_directory}}}{\emph{image\_dir}, \emph{composite\_out\_dir}, \emph{format='GTiff'}, \emph{generate\_date\_images=False}}{}
Composites every image in image\_dir, assumes all have associated masks.  Will
place a file named composite\_{[}last image date{]}.tif inside composite\_out\_dir

\end{fulllineitems}

\index{composite\_images\_with\_mask() (in module pyeo.raster\_manipulation)@\spxentry{composite\_images\_with\_mask()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.composite_images_with_mask}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{composite\_images\_with\_mask}}}{\emph{in\_raster\_path\_list}, \emph{composite\_out\_path}, \emph{format='GTiff'}, \emph{generate\_date\_image=False}}{}
Works down in\_raster\_path\_list, updating pixels in composite\_out\_path if not masked. Masks are assumed to
be a binary .msk file with the same path as their corresponding image. All images must have the same
number of layers and resolution, but do not have to be perfectly on top of each other. If it does not exist,
composite\_out\_path will be created. Takes projection, resolution, ect from first band of first raster in list.
Will reproject images and masks if they do not match initial raster.

\end{fulllineitems}

\index{create\_mask\_from\_class\_map() (in module pyeo.raster\_manipulation)@\spxentry{create\_mask\_from\_class\_map()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.create_mask_from_class_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{create\_mask\_from\_class\_map}}}{\emph{class\_map\_path}, \emph{out\_path}, \emph{classes\_of\_interest}, \emph{buffer\_size=0}, \emph{out\_resolution=None}}{}
Creates a mask from a classification mask: 1 for each pixel containing one of classes\_of\_interest, otherwise 0

\end{fulllineitems}

\index{create\_mask\_from\_confidence\_layer() (in module pyeo.raster\_manipulation)@\spxentry{create\_mask\_from\_confidence\_layer()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.create_mask_from_confidence_layer}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{create\_mask\_from\_confidence\_layer}}}{\emph{l2\_safe\_path}, \emph{out\_path}, \emph{cloud\_conf\_threshold=0}, \emph{buffer\_size=3}}{}
Creates a multiplicative binary mask where cloudy pixels are 0 and non-cloudy pixels are 1. If
cloud\_conf\_threshold = 0, use scl mask else use confidence image

\end{fulllineitems}

\index{create\_mask\_from\_model() (in module pyeo.raster\_manipulation)@\spxentry{create\_mask\_from\_model()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.create_mask_from_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{create\_mask\_from\_model}}}{\emph{image\_path}, \emph{model\_path}, \emph{model\_clear=0}, \emph{num\_chunks=10}, \emph{buffer\_size=0}}{}
Returns a multiplicative mask (0 for cloud, shadow or haze, 1 for clear) built from the model at model\_path.

\end{fulllineitems}

\index{create\_matching\_dataset() (in module pyeo.raster\_manipulation)@\spxentry{create\_matching\_dataset()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.create_matching_dataset}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{create\_matching\_dataset}}}{\emph{in\_dataset}, \emph{out\_path}, \emph{format='GTiff'}, \emph{bands=1}, \emph{datatype=None}}{}
Creates an empty gdal dataset with the same dimensions, projection and geotransform. Defaults to 1 band.
Datatype is set from the first layer of in\_dataset if unspecified

\end{fulllineitems}

\index{create\_new\_image\_from\_polygon() (in module pyeo.raster\_manipulation)@\spxentry{create\_new\_image\_from\_polygon()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.create_new_image_from_polygon}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{create\_new\_image\_from\_polygon}}}{\emph{polygon}, \emph{out\_path}, \emph{x\_res}, \emph{y\_res}, \emph{bands}, \emph{projection}, \emph{format='GTiff'}, \emph{datatype=5}, \emph{nodata=-9999}}{}
Returns an empty image of the extent of input polygon

\end{fulllineitems}

\index{create\_new\_stacks() (in module pyeo.raster\_manipulation)@\spxentry{create\_new\_stacks()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.create_new_stacks}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{create\_new\_stacks}}}{\emph{image\_dir}, \emph{stack\_dir}}{}
Creates new stacks with with adjacent image acquisition dates. Threshold; how small a part
of the latest\_image will be before it’s considered to be fully processed.
New\_image\_name must exist inside image\_dir.
\begin{description}
\item[{Step 1: Sort directory as follows:}] \leavevmode
Relative Orbit number (RO4O), then Tile Number (T15PXT), then
Datatake sensing start date (YYYYMMDD) and time(THHMMSS).
newest first.

\item[{Step 2: For each tile number:}] \leavevmode
new\_data\_polygon = bounds(new\_image\_name)

\item[{Step 3: For each tiff image coverring that tile, work backwards in time:}] \leavevmode\begin{enumerate}
\def\theenumi{\alph{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Check if it intersects new\_data\_polygon

\item {} 
If it does
- add to a to\_be\_stacked list,
- subtract it’s bounding box from new\_data\_polygon.

\item {} 
If new\_data\_polygon drops having a total area less than threshold, stop.

\end{enumerate}

\end{description}

Step 4: Stack new rasters for each tile in new\_data list.

\end{fulllineitems}

\index{filter\_by\_class\_map() (in module pyeo.raster\_manipulation)@\spxentry{filter\_by\_class\_map()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.filter_by_class_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{filter\_by\_class\_map}}}{\emph{image\_path}, \emph{class\_map\_path}, \emph{out\_map\_path}, \emph{classes\_of\_interest}, \emph{out\_resolution=10}}{}
Filters class\_map\_path for pixels in filter\_map\_path containing only classes\_of\_interest.
Assumes that filter\_map\_path and class\_map\_path are same resolution and projection.

\end{fulllineitems}

\index{flatten\_probability\_image() (in module pyeo.raster\_manipulation)@\spxentry{flatten\_probability\_image()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.flatten_probability_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{flatten\_probability\_image}}}{\emph{prob\_image}, \emph{out\_path}}{}
Produces a single-band raster containing the highest certainties in a input probablility raster

\end{fulllineitems}

\index{get\_masked\_array() (in module pyeo.raster\_manipulation)@\spxentry{get\_masked\_array()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.get_masked_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{get\_masked\_array}}}{\emph{raster}, \emph{mask\_path}, \emph{fill\_value=-9999}}{}
Returns a numpy.mask masked array for the raster.
Masked pixels are FALSE in the mask image (multiplicateive map),
but TRUE in the masked\_array (nodata pixels)

\end{fulllineitems}

\index{mosaic\_images() (in module pyeo.raster\_manipulation)@\spxentry{mosaic\_images()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.mosaic_images}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{mosaic\_images}}}{\emph{raster\_paths}, \emph{out\_raster\_file}, \emph{format='GTiff'}, \emph{datatype=5}, \emph{nodata=0}}{}
Mosaics multiple images with the same number of layers into one single image. Overwrites
overlapping pixels with the value furthest down raster\_paths. Takes projection from the first
raster.

TODO: consider using GDAL:
\begin{description}
\item[{gdal\_merge.py {[}-o out\_filename{]} {[}-of out\_format{]} {[}-co NAME=VALUE{]}*}] \leavevmode
{[}-ps pixelsize\_x pixelsize\_y{]} {[}-tap{]} {[}-separate{]} {[}-q{]} {[}-v{]} {[}-pct{]}
{[}-ul\_lr ulx uly lrx lry{]} {[}-init “value {[}value…{]}”{]}
{[}-n nodata\_value{]} {[}-a\_nodata output\_nodata\_value{]}
{[}-ot datatype{]} {[}-createonly{]} input\_files

\end{description}

\end{fulllineitems}

\index{open\_dataset\_from\_safe() (in module pyeo.raster\_manipulation)@\spxentry{open\_dataset\_from\_safe()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.open_dataset_from_safe}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{open\_dataset\_from\_safe}}}{\emph{safe\_file\_path}, \emph{band}, \emph{resolution='10m'}}{}
Opens a dataset given a safe file. Give band as a string.

\end{fulllineitems}

\index{preprocess\_sen2\_images() (in module pyeo.raster\_manipulation)@\spxentry{preprocess\_sen2\_images()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.preprocess_sen2_images}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{preprocess\_sen2\_images}}}{\emph{l2\_dir}, \emph{out\_dir}, \emph{l1\_dir}, \emph{cloud\_threshold=60}, \emph{buffer\_size=0}, \emph{epsg=None}}{}
For every .SAFE folder in in\_dir, stacks band 2,3,4 and 8  bands into a single geotif, creates a cloudmask from
the combined fmask and sen2cor cloudmasks and reprojects to a given EPSG if provided

\end{fulllineitems}

\index{raster\_sum() (in module pyeo.raster\_manipulation)@\spxentry{raster\_sum()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.raster_sum}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{raster\_sum}}}{\emph{inRstList}, \emph{outFn}, \emph{outFmt='GTiff'}}{}
Creates a raster stack from a list of rasters. Adapted from Chris Gerard’s
book ‘Geoprocessing with Python’. The out put data type is the same as the input data type.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inRstList}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} List of rasters to stack.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outFmt}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} String specifying the input data format e.g. ‘GTiff’ or ‘VRT’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outFn}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Filename output as str including directory else image will be

\end{itemize}

\end{description}\end{quote}

written to current working directory.

\end{fulllineitems}

\index{raster\_to\_array() (in module pyeo.raster\_manipulation)@\spxentry{raster\_to\_array()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.raster_to_array}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{raster\_to\_array}}}{\emph{rst\_pth}}{}
Reads in a raster file and returns a N-dimensional array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{rst\_pth}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to input raster.

\item[{Returns}] \leavevmode
N-dimensional array.

\end{description}\end{quote}

\end{fulllineitems}

\index{reproject\_directory() (in module pyeo.raster\_manipulation)@\spxentry{reproject\_directory()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.reproject_directory}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{reproject\_directory}}}{\emph{in\_dir}, \emph{out\_dir}, \emph{new\_projection}, \emph{extension='.tif'}}{}
Reprojects every file ending with extension to new\_projection and saves in out\_dir

\end{fulllineitems}

\index{reproject\_image() (in module pyeo.raster\_manipulation)@\spxentry{reproject\_image()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.reproject_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{reproject\_image}}}{\emph{in\_raster}, \emph{out\_raster\_path}, \emph{new\_projection}, \emph{driver='GTiff'}, \emph{memory=2000.0}, \emph{do\_post\_resample=True}}{}
Creates a new, reprojected image from in\_raster. Wraps gdal.ReprojectImage function. Will round projection
back to whatever 2gb memory limit by default (because it works in most places)

\end{fulllineitems}

\index{resample\_image\_in\_place() (in module pyeo.raster\_manipulation)@\spxentry{resample\_image\_in\_place()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.resample_image_in_place}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{resample\_image\_in\_place}}}{\emph{image\_path}, \emph{new\_res}}{}
Resamples an image in-place using gdalwarp to new\_res in metres

\end{fulllineitems}

\index{save\_array\_as\_image() (in module pyeo.raster\_manipulation)@\spxentry{save\_array\_as\_image()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.save_array_as_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{save\_array\_as\_image}}}{\emph{array}, \emph{path}, \emph{geotransform}, \emph{projection}, \emph{format='GTiff'}}{}
Saves a given array as a geospatial image in the format ‘format’
Array must be gdal format: {[}bands, y, x{]}. Returns the gdal object

\end{fulllineitems}

\index{stack\_and\_trim\_images() (in module pyeo.raster\_manipulation)@\spxentry{stack\_and\_trim\_images()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.stack_and_trim_images}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{stack\_and\_trim\_images}}}{\emph{old\_image\_path}, \emph{new\_image\_path}, \emph{aoi\_path}, \emph{out\_image}}{}
Stacks an old and new S2 image and trims to within an aoi

\end{fulllineitems}

\index{stack\_image\_with\_composite() (in module pyeo.raster\_manipulation)@\spxentry{stack\_image\_with\_composite()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.stack_image_with_composite}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{stack\_image\_with\_composite}}}{\emph{image\_path}, \emph{composite\_path}, \emph{out\_dir}, \emph{create\_combined\_mask=True}, \emph{skip\_if\_exists=True}, \emph{invert\_stack=False}}{}
Stacks an image with a cloud-free composite

\end{fulllineitems}

\index{stack\_images() (in module pyeo.raster\_manipulation)@\spxentry{stack\_images()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.stack_images}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{stack\_images}}}{\emph{raster\_paths}, \emph{out\_raster\_path}, \emph{geometry\_mode='intersect'}, \emph{format='GTiff'}, \emph{datatype=5}}{}
Stacks multiple images in image\_paths together, using the information of the top image.
geometry\_mode can be “union” or “intersect”

\end{fulllineitems}

\index{stack\_old\_and\_new\_images() (in module pyeo.raster\_manipulation)@\spxentry{stack\_old\_and\_new\_images()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.stack_old_and_new_images}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{stack\_old\_and\_new\_images}}}{\emph{old\_image\_path}, \emph{new\_image\_path}, \emph{out\_dir}, \emph{create\_combined\_mask=True}}{}
Stacks two images with the same tile
Names the result with the two timestamps.
First, decompose the granule ID into its components:
e.g. S2A, MSIL2A, 20180301, T162211, N0206, R040, T15PXT, 20180301, T194348
are the mission ID(S2A/S2B), product level(L2A), datatake sensing start date (YYYYMMDD) and time(THHMMSS),
the Processing Baseline number (N0206), Relative Orbit number (RO4O), Tile Number field (T15PXT),
followed by processing run date and then time

\end{fulllineitems}

\index{stack\_sentinel\_2\_bands() (in module pyeo.raster\_manipulation)@\spxentry{stack\_sentinel\_2\_bands()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.stack_sentinel_2_bands}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{stack\_sentinel\_2\_bands}}}{\emph{safe\_dir}, \emph{out\_image\_path}, \emph{band='10m'}}{}
Stacks the contents of a .SAFE granule directory into a single geotiff

\end{fulllineitems}

\index{trim\_image() (in module pyeo.raster\_manipulation)@\spxentry{trim\_image()}\spxextra{in module pyeo.raster\_manipulation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.raster_manipulation.trim_image}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.raster\_manipulation.}}\sphinxbfcode{\sphinxupquote{trim\_image}}}{\emph{in\_raster\_path}, \emph{out\_raster\_path}, \emph{polygon}, \emph{format='GTiff'}}{}
Trims image to polygon

\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-pyeo.validation}}\index{pyeo.validation (module)@\spxentry{pyeo.validation}\spxextra{module}}

\section{pyeo.validaion}
\label{\detokenize{index:pyeo-validaion}}
A small set of functions for producing validation points from maps
\index{allocate\_category\_sample\_sizes() (in module pyeo.validation)@\spxentry{allocate\_category\_sample\_sizes()}\spxextra{in module pyeo.validation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.validation.allocate_category_sample_sizes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.validation.}}\sphinxbfcode{\sphinxupquote{allocate\_category\_sample\_sizes}}}{\emph{total\_sample\_size}, \emph{user\_accuracy}, \emph{class\_total\_sizes}, \emph{variance\_tolerance}, \emph{allocate\_type='olofsson'}}{}
Allocates a number of pixels to sample per class that will fulfil the parameters given
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{total\_sample\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{The total number of validation points requested}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{from cal\_total\_sample\_size}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{user\_accuracy}} (\sphinxstyleliteralemphasis{\sphinxupquote{Dictionary of estimated user accuracies for classes in map}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{between 0 and 1}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{class\_total\_sizes}} (\sphinxstyleliteralemphasis{\sphinxupquote{Dictionary of total pixels for each class in user\_accuracy}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variance\_tolerance}} (\sphinxstyleliteralemphasis{\sphinxupquote{Acceptable vairance between the sample accuary and the data accuracy with a certain sample size}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{allocate\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{The allocation strategy to be used. Can be 'equal'}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{'prop'}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{'olofsson'.}}) \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
A dictionary of classes and no. pixels per class.

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_class\_dict() (in module pyeo.validation)@\spxentry{build\_class\_dict()}\spxextra{in module pyeo.validation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.validation.build_class_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.validation.}}\sphinxbfcode{\sphinxupquote{build\_class\_dict}}}{\emph{class\_array}, \emph{no\_data=None}}{}
Returns a dict of coordinates of the following shape:
{[}class, coord{]}.
WARNING: This will take up a LOT of memory!

\end{fulllineitems}

\index{cal\_total\_sample\_size() (in module pyeo.validation)@\spxentry{cal\_total\_sample\_size()}\spxextra{in module pyeo.validation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.validation.cal_total_sample_size}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.validation.}}\sphinxbfcode{\sphinxupquote{cal\_total\_sample\_size}}}{\emph{desired\_standard\_error}, \emph{user\_accuracy}, \emph{total\_class\_sizes}, \emph{type='simple'}}{}
Calculates the number of sample points for a map to get a specified standard error.
:param desired\_standard\_error:
:type desired\_standard\_error: The desired standard error (between 0 and 1)
:param user\_accuracy:
:type user\_accuracy: A dictionary of user accuracies from apriori knowledge
:param total\_class\_sizes:
:type total\_class\_sizes: The total number of pixels for each class
:param type:
:type type: whether to use the simple approximation or the full expession from Olofsson eq 13
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
The total number of sample points to achieve the specified error

\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_minimum\_n() (in module pyeo.validation)@\spxentry{calc\_minimum\_n()}\spxextra{in module pyeo.validation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.validation.calc_minimum_n}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.validation.}}\sphinxbfcode{\sphinxupquote{calc\_minimum\_n}}}{\emph{expected\_accuracy}, \emph{variance\_tolerance}}{}
Calculates the rminimum number of points required to achieve the specified accuracy
:param expected\_accuracy:
:type expected\_accuracy: Between 0 and 1
:param variance\_tolerance:

\end{fulllineitems}

\index{count\_pixel\_classes() (in module pyeo.validation)@\spxentry{count\_pixel\_classes()}\spxextra{in module pyeo.validation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.validation.count_pixel_classes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.validation.}}\sphinxbfcode{\sphinxupquote{count\_pixel\_classes}}}{\emph{map\_path}, \emph{no\_data=None}}{}
Counts pixels in a map. Returns a dictionary of pixels.
:param map\_path:
:type map\_path: Path to the map to count
:param no\_data:
:type no\_data: A value to ignore
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{A dictionary of class}

\item[{Return type}] \leavevmode
count

\end{description}\end{quote}

\end{fulllineitems}

\index{part\_fixed\_value\_sampling() (in module pyeo.validation)@\spxentry{part\_fixed\_value\_sampling()}\spxextra{in module pyeo.validation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.validation.part_fixed_value_sampling}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.validation.}}\sphinxbfcode{\sphinxupquote{part\_fixed\_value\_sampling}}}{\emph{pinned\_sample\_numbers}, \emph{class\_total\_sizes}, \emph{total\_sample\_size}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pinned\_sample\_numbers}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{class\_total\_sizes}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{total\_sample\_size}} \textendash{} 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{produce\_stratifed\_validation\_points() (in module pyeo.validation)@\spxentry{produce\_stratifed\_validation\_points()}\spxextra{in module pyeo.validation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.validation.produce_stratified_validation_points}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.validation.}}\sphinxbfcode{\sphinxupquote{produce\_stratifed\_validation\_points}}}{\emph{map\_path}, \emph{out\_path}, \emph{class\_sample\_counts}, \emph{no\_data=None}, \emph{seed=None}, \emph{produce\_csv=False}}{}
Produces a set of stratified validation points from map\_path

\end{fulllineitems}

\index{save\_point\_list\_to\_shapefile() (in module pyeo.validation)@\spxentry{save\_point\_list\_to\_shapefile()}\spxextra{in module pyeo.validation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.validation.save_point_list_to_shapefile}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.validation.}}\sphinxbfcode{\sphinxupquote{save\_point\_list\_to\_shapefile}}}{\emph{class\_sample\_point\_dict}, \emph{out\_path}, \emph{geotransform}, \emph{projection\_wkt}, \emph{produce\_csv=False}}{}
Saves a list of points to a shapefile at out\_path. Need the gt and projection of the raster.
GT is needed to move each point to the centre of the pixel. Can also produce a .csv file for CoolEarth

\end{fulllineitems}

\index{save\_validation\_maifest() (in module pyeo.validation)@\spxentry{save\_validation\_maifest()}\spxextra{in module pyeo.validation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.validation.save_validation_maifest}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.validation.}}\sphinxbfcode{\sphinxupquote{save\_validation\_maifest}}}{\emph{out\_path}, \emph{class\_counts}, \emph{sample\_size}, \emph{class\_sample\_counts}, \emph{target\_standard\_error}, \emph{user\_accuracies}}{}
Creates a json file containing the parameters used to produce this validation set

\end{fulllineitems}

\index{stratified\_random\_sample() (in module pyeo.validation)@\spxentry{stratified\_random\_sample()}\spxextra{in module pyeo.validation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:pyeo.validation.stratified_random_sample}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pyeo.validation.}}\sphinxbfcode{\sphinxupquote{stratified\_random\_sample}}}{\emph{map\_path}, \emph{class\_sample\_count}, \emph{no\_data=None}, \emph{seed=None}}{}
Produces a stratified list of pixel coordinates. WARNING: high mem!

\end{fulllineitems}


A small test suite is located in pyeo/tests/pyeo\_tests.py; this is designed for use with py.test.
Some example applications and demos are in pyeo/apps; for an illustration of the use of the library,
pyeo/apps/change\_detection/simple\_s2\_change\_detection.py is recommended.


\chapter{Applications}
\label{\detokenize{index:module-pyeo.apps.change_detection.image_comparison}}\label{\detokenize{index:applications}}\index{pyeo.apps.change\_detection.image\_comparison (module)@\spxentry{pyeo.apps.change\_detection.image\_comparison}\spxextra{module}}

\section{image\_comparison}
\label{\detokenize{index:image-comparison}}
An application for applying a pickled scikit-learn model to two contiguous raster images.

Example call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}image\PYGZus{}comparison image\PYGZus{}1.tif image\PYGZus{}2.tif model.pkl class\PYGZus{}map.tif
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{index:module-pyeo.apps.change_detection.rolling_composite_s2_change_detection}}\index{pyeo.apps.change\_detection.rolling\_composite\_s2\_change\_detection (module)@\spxentry{pyeo.apps.change\_detection.rolling\_composite\_s2\_change\_detection}\spxextra{module}}

\section{rolling\_composite\_s2\_change\_detection}
\label{\detokenize{index:rolling-composite-s2-change-detection}}\begin{description}
\item[{An app for providing continuous change detection. Runs the following algorithm}] \leavevmode
Step -1: Create initial composite with last date (stored in filename?)

Step 0: Load composite

Step 1: Download images from last date in composite until present last date

Step 2: Preprocess each image

Step 3: Generate cloud mask for each image

\end{description}

For each preprocessed image:
\begin{quote}

Step 4: Build stack with composite

Step 5: Classify stack

Step 6: Update composite with last cloud-free pixel based on cloud mask

Step 7: Update last\_date of composite
\end{quote}
\phantomsection\label{\detokenize{index:module-pyeo.apps.change_detection.simple_s2_change_detection}}\index{pyeo.apps.change\_detection.simple\_s2\_change\_detection (module)@\spxentry{pyeo.apps.change\_detection.simple\_s2\_change\_detection}\spxextra{module}}

\section{simple\_s2\_change\_detection}
\label{\detokenize{index:simple-s2-change-detection}}
A change detection script that downloads, stacks and classifies a set of 10m sentinel 2 images.

When run, this script will download every S2 image in the aoi (defined by the geojson at aoi\_path) between the two
dates that meets the specified cloud cover range. It will use the sen2cor distribution specified in the .ini file
to atmospherically correct the data to L2A, merge each set of 10m bands into a single geotiff, stack the images
into pairs based on the algorithm in create\_new\_stacks and classify those images using a scikit-learn model

To use this script, fill out the {[}sent\_2{]}, {[}forest\_sentinel{]} and {[}sen2cor{]} sections of the configuration file
change\_detection.ini, then run

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python pyeo/apps/change\PYGZus{}detection/simple\PYGZus{}s2\PYGZus{}change\PYGZus{}detection.py \PYGZhy{}\PYGZhy{}conf /path/to/change\PYGZus{}detection.ini
\end{sphinxVerbatim}

Produces two directories of un-mosaiced imagery; one of classified images and one of class probabilites
\phantomsection\label{\detokenize{index:module-pyeo.apps.masking.filter_by_class_map}}\index{pyeo.apps.masking.filter\_by\_class\_map (module)@\spxentry{pyeo.apps.masking.filter\_by\_class\_map}\spxextra{module}}

\section{filter\_by\_class\_map}
\label{\detokenize{index:filter-by-class-map}}
Filters every pixel in input\_image that is not one of filter\_classes.

Usage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} filter\PYGZus{}by\PYGZus{}class\PYGZus{}map my\PYGZus{}image.tif my\PYGZus{}class\PYGZus{}map.tif my\PYGZus{}output\PYGZus{}image.tif useful\PYGZus{}class\PYGZus{}1 useful\PYGZus{}class\PYGZus{}2
\end{sphinxVerbatim}

This will create an image, my\_output\_image.tif, that contains only the pixels from my\_image.tif
that are labelled as useful\_class\_1 and useful\_class\_2 in my\_class\_map.tif
\phantomsection\label{\detokenize{index:module-pyeo.apps.model_creation.create_model_from_region}}\index{pyeo.apps.model\_creation.create\_model\_from\_region (module)@\spxentry{pyeo.apps.model\_creation.create\_model\_from\_region}\spxextra{module}}

\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{p}
\item\relax\sphinxstyleindexentry{pyeo.apps.change\_detection.image\_comparison}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.apps.change_detection.image_comparison}}
\item\relax\sphinxstyleindexentry{pyeo.apps.change\_detection.rolling\_composite\_s2\_change\_detection}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.apps.change_detection.rolling_composite_s2_change_detection}}
\item\relax\sphinxstyleindexentry{pyeo.apps.change\_detection.simple\_s2\_change\_detection}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.apps.change_detection.simple_s2_change_detection}}
\item\relax\sphinxstyleindexentry{pyeo.apps.masking.filter\_by\_class\_map}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.apps.masking.filter_by_class_map}}
\item\relax\sphinxstyleindexentry{pyeo.apps.model\_creation.create\_model\_from\_region}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.apps.model_creation.create_model_from_region}}
\item\relax\sphinxstyleindexentry{pyeo.array\_utilities}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.array_utilities}}
\item\relax\sphinxstyleindexentry{pyeo.classification}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.classification}}
\item\relax\sphinxstyleindexentry{pyeo.coordinate\_manipulation}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.coordinate_manipulation}}
\item\relax\sphinxstyleindexentry{pyeo.filesystem\_utilities}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.filesystem_utilities}}
\item\relax\sphinxstyleindexentry{pyeo.queries\_and\_downloads}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.queries_and_downloads}}
\item\relax\sphinxstyleindexentry{pyeo.raster\_manipulation}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.raster_manipulation}}
\item\relax\sphinxstyleindexentry{pyeo.validation}\sphinxstyleindexpageref{index:\detokenize{module-pyeo.validation}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}